<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EECS475_MachineLearning]]></title>
    <url>%2F2018%2F12%2F17%2FEECS475-MachineLearning%2F</url>
    <content type="text"><![CDATA[Machine Learning Introduction It is really strange about ML. Because at first I thought it is something difficult, and the work in the real world is the same. But after talking with some classmates, I find that most of them just use the model, and don’t know the truth of it, which goes against my idea of study. All the time I think, no matter what, I need to absorb the truth of one thing to convince myself that I am really understand it. But my classmate gives me a feeling that this field has a low threshold and this feeling makes me uncomfortable.I know ML is the frontier of computer science but it hurts me when I find this phnomenon. I am really interested in ML. I hope I can be another kinds of people who really understand the concept of ML.I know I am just talking, but I hope I can do what I said. Linear regression logicla regression classification 2 classification n classification non-linear regression]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EECS376_Game_Design_and_Development]]></title>
    <url>%2F2018%2F12%2F17%2FEECS376-Game-Design-and-Development%2F</url>
    <content type="text"></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EECS495_Intro_to_database]]></title>
    <url>%2F2018%2F12%2F17%2FEECS495-Intro-to-database%2F</url>
    <content type="text"><![CDATA[Intro to Database this is a brief summary of this course, since quarter is at the end, no excuse not to write a summary :-)I will summary every chapter of this course and then make a whole summary. DB fundamentalsDatabase like txt file or another file storage type. It stores data, but why we design a new model to store the data not just use what we have now? Because of efficiency, database can retrieve data more quick than normal type file storage. Moreover, it can normalize the data to make them more conpact to reduce space usage which is also important for large scale system.Database is a large collection of organized data.Database Management System(DBMS) is a tool designed to manage and utilize databases. In database, there is one important concept: Table, it contains several components: Schema: Descripor of the records stored in a table. Attribute: A column of a table Tuple: A record/row in a table Field: A cell in a tuple Here is a illustration picture: Query Language is a specialized laguage for retrieving and manipulating data used with a DBMS, but a Query is just a command written in Query Language to DBMS. Here is an example query language(MySQL): SELECT department, COUNT(*) FROM employees e WHERE e.age &gt; 18 GROUP BY department ERDA direct diagram to illustrate the relationship between different entities, but what is entity? Entity is a box, containg all the information in a table. You can see it as a pictural discriptor of table. It contains attributes, and relationships with other entities. Entity: a rectangle Attribute: an oval (Primary Key should be highlighted with a underline) Relationship: a line with some notation (To indicate 1-1, 1-M, M-M relationship) (It can contains Attrs too) Generalization Hierarchy: Disjoint: can be only one of them Overlapping: can be any of them. isa hierarchy: will be introduce in the future Weak Entity:Occurs in 1-M relationships, for example, in 2 different teams, both has a teammate called No.2, then we have to combine team name and their number to locate the person accurately.[This entity will be represented by a double rectangle] Here is a example, including both normal ERD and weak entity: Relational ModelWhen we get ERD, how we change it into a relational model, which is also known as schema? Here are some solutions for different kinds of problems. 1-M Add the key of “1” entity, as a foreign key to the table of “M” entity Add the attributes of the relationship type M-M We add the key of both entities to relationship model. 1-1 This is a special case for 1-M, so it is the same. Weak Entity This is also a special case for 1-M, so we add primary key of Strong entity as a foreign key to the weak entity. Subclass Objected-oriented: create a model for each entity, but subclasses will contains every attributes of parent’s entity. This is useful for queries involving both common and special attributes. Use nulls: create only one parent entity and add all subclass’s attributes to parent’s model. This is useful for queries like special member number almost equals to number of members in superclass. ER style: Create a model for each entity, and subclass only contains parent’s primary key(s) This is useful for queries involving the the common attributes of the superclass. Relational AlgebraWhen we have Relational Model, how we retrieve the data we want? Sometimes we can get the data just from one model, but most of the time we have to retrieve data from the combination of different models(schemas). Relational Algebra is used to do this stuff. It helps us to be more clear about the procedure to retrieve the required data. Union $R1 \bigcup R2$ Intersection $R1 \bigcap R2$ Difference $R1 - R2$ Projection $\pi_{A1,A2, …}(R)$, we project corresponding columns out of relation R Selection $\sigma_{length \geq 100}(Movies)$, we select rows in Movies those length is greater or equals to 100. Cartesian(Cross) Product $R1 \times R2$ Theta(Conditional) Join $R1 \bowtie_{C} R2$ Natural join connect 2 relations by common attributes and same field. Rename $R1 = \rho_{R1(A1, …, An)}(R2)$ We commonly use expression tree or relational algebra to express the data we want to retrieve. Here is 2 examples respectively. QUERY : The names of all the bars that are either on MapleSt. or sell Bud for less than $3. QUERY : patient IDs that have seen a pediatricianwe have scheme as follows:hospital(hosp_id, h_name, h_addr)doctor(doctor_id, d_name, d_specialty, hosp_id)patient(patient_id, p_name, p_dob, doctor_id)$\pi_{patient}(patients \bowtie_{doctor_id}\sigma_{specialty=’pediatrician’}(doctors))$ SQL Part ISQL Part IIAdvanced SQLProgramming in SQLPL/SQL and Functional DependencyNormalizationTransactionDeadlock &amp; Isolation LevelDisk Storage &amp; ManagementIndexingHashed Indexing &amp; Query CostJoin &amp; Multidim ModelingMDX QueriesGraph Database]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HexoConfig]]></title>
    <url>%2F2018%2F12%2F17%2FHexoConfig%2F</url>
    <content type="text"><![CDATA[Hexo Configs &amp; Frequent Problems Here are some useful configurations for hexo. beautify the article with shadow 1234567891011/* path:themes/next/source/css/_custom/custom.styl */.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;/*Get from: https://www.jianshu.com/p/d34e9531cfce*/ Avatar rotation 12345678910111213141516171819202122232425262728/* path:themes/next/source/css/_custom/custom.styl */.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(0.9); moz-transform: rotate(360deg) scale(0.9); ms-transform: rotate(360deg) scale(0.9); transform: rotate(360deg) scale(0.9);&#125;/* end *//*Get from: https://www.jianshu.com/p/d34e9531cfce*/ Social icons don’t appear 1234567891011social: GitHub: https://github.com/TCoherence || github E-Mail: mailto:hanzhiyang2019@gmail.com || envelope #Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yang_hanzhi || twitter FB Page: https://www.facebook.com/profile.php?id=100025563873836 || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype The final code should be something like this. ‘social’ cannot be commented out.]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Summary ByTag]]></title>
    <url>%2F2018%2F09%2F19%2FLeetCode-Summary-ByTag%2F</url>
    <content type="text"><![CDATA[LeetCode Summary By Tag To make it easier to review the leetcode, classify different into groups according to its tags. LeetCode Summary By Tag 1. Array 1. Two Sum 11. Container With Most Water 15. 3Sum 16. 3Sum Closest 18. 4Sum 26. Remove Duplicates from Sorted Array 27. Remove Element 41. First Missing Positive 42. Trapping Rain Water 2. Number 3. List 1. Array1. Two SumDiscription: Click HereIdea:a. loop through + binary search; O(N)*O(logN) = O(NlogN) time performance, O(1) space cose;b. HashMap to record the whole array then loop through the array.O(N) time performance and O(N) space cose; 11. Container With Most WaterDiscription: Click HereIdea:two pointers, move the lower one to the higher one, update localMax and globalMax. 15. 3SumDiscription: Clikc HereIdea:3 pointers, a, b, and c.FIRST, sort the array.a is used to loop throught the first num, b and c are used to scan the remaining array element from two sides. which leads to O(N) time. With O(N) time to LOOP throught the whole array, we use up to $O(N^2)$ time. 16. 3Sum ClosestDiscription: Click HereIdea:Same idea with #15 18. 4SumDiscription: Click HereIdea:Same idea with #15, but need 4 pointers and cost $O(N^3)$ time. 26. Remove Duplicates from Sorted ArrayDiscription: Click HereIdea:In-place, so we can record how many repeated numbers in this array and move the first of duplicates or non-duplicate forward. 27. Remove ElementDiscription: Click HereIdea:Same with #26 41. First Missing PositiveDiscription: Click HereIdea:Build an array to record the presence of positive integer. Loop the whole array to update this array. Then loop this array from start and we will find the first missing positive number. This costs O(N) time. 42. Trapping Rain WaterDiscription: Click HereIdea:1) Builde 2 pointers, left and right. move the lower one to higher one;2) we need to update trapped water in a way that lower one stop once encounter a higher one. Say that left one is lower one, we move a temp pointer to right and every movement we see if current value(where pointer points) is lower than the value left pointer points.3) If it is then update left pointer to temp pointer.4) If not, return to 2. 2. Number3. List]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode New Summary]]></title>
    <url>%2F2018%2F06%2F18%2FLeetCode-New-Summary%2F</url>
    <content type="text"><![CDATA[LeetCode New Summaryautoauto- LeetCode New Summaryauto- 0 - 100auto - 1. Two Sumauto - 2. Add Two Numbersauto - 3. Longest Substring Without Repeating Charactersauto - 4. Median of Two Sorted Arraysauto - 91. Decode Waysauto- 100 - 200auto - 104. Maximum Depth of Binary Treeauto - 136. Single Number [E]auto- 200 - 300auto - 274. H-Indexauto - 292. Nim Gameauto- 300 - 400auto - 337. House Robber IIIauto - 344. Reverse String [E]auto- 400 - 500auto - 461. Hamming Distance [Easy]auto - 463. Island Perimeterauto- 500 - 600auto - 513. Find Bottom Left Tree Value [Medium]auto - 561. Array Partition Iauto- 600 - 700auto - 605. Can Place Flowersauto - 637. Average of Levels in Binary Treeauto - 646. Maximum Length of Pair Chainauto - 657. Judge Route Circle [Easy]auto - 693. Binary Number with Alternating Bitsauto - 698. Partition to K Equal Sum Subsetsauto- 700 - 800auto - 766. Toeplitz Matrixauto- 800 - 900auto - 811. Subdomain Visit Count [Easy]auto - 852. Peak Index in a Mountain Arrayauto - 853. Car Fleetauto - 854. K-Similar Stringsauto - 855. Exam Roomautoauto This is a review of every lc problems I have done. 0 - 1001. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. IDEA:a. sorted -&gt; binary search -&gt; O(N) to search first num and O(logN) which leads to O(NlogN) in total and O(1) space cost.b. use HashMap, O(N) time cost and O(N) space cose. 2. Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. IDEA:a. one temp var to record carry bit. 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Example 1:Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3.Example 2:Input: “bbbbb”Output: 1Explanation: The answer is “b”, with the length of 1.Example 3:Input: “pwwkew”Output: 3Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. IDEA:record every char’s index, once repeat, update globalMaxLength and localMaxLength; 4. Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 IDEA:need to be write in detailThe median of an array is a number that divide the array into 2 subarray, every num in the left array is smaller than the median and every num in the right array is larger than the median. 91. Decode WaysA message containing letters from A-Z is being encoded to numbers using the following mapping: ‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: “12”Output: 2Explanation: It could be decoded as “AB” (1 2) or “L” (12). Example 2: Input: “226”Output: 3Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6). IDEA:DP solution:Apparently, for every digit we need to see if it is valid([1 ~ 9]), then the digit comes after need to do the check too([10 ~ 26]), so we have 2 choices for every digit except for some corner cases.Let’s consider buttom-up solution, which is from right to left in this problem. For i-th digit, if it is valid, then #the i-th total decode ways += total (i+1)-th decode ways. If (i_i+1) two digits are valid, then #the i-th total decode ways += (i+2)-th decode ways. This is showed as follows:DP[i] = DP[i + 1] + DP[i + 2] 100 - 200104. Maximum Depth of Binary TreeGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. IDEA:dfs, recursive solution 136. Single Number [E]Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1]Output: 1 Example 2: Input: [4,1,2,1,2]Output: 4 IDEA:linear time -&gt; two loop, one loop to calculate the freq and one loop to find the single number.If require no extra memory, we can use ^ oprator, because a ^ a ^ b = b. 200 - 300274. H-IndexGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” Example: Input: citations = [3,0,6,1,5]Output: 3Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3. IDEA:Solution 1:sort the array, back to front.Time Performance: O(nlogn)Space Performance: O(1) Solution 2:The key of this problem is that the range of h is [0, N], so we can use bucket index to present potential h-idx and the value in bucket to denote the number of papers cited more than bucket index.So one loop for original array to update bucket array and one loop for bucket array to find h-idx.Time Performance: O(N)Space Performance: O(N) 292. Nim GameYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. IDEA:it is important to find that it is relative to those multiples of 4. 300 - 400337. House Robber IIIThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. IDEA:naive recursive solution -&gt; pruning solution(using HashMap) -&gt; DP solution(return results under 2 different conditions) 344. Reverse String [E]Write a function that takes a string as input and returns the string reversed. Example:Given s = “hello”, return “olleh”. IDEA:easy swap 400 - 500461. Hamming Distance [Easy]The Hamming distance between two integers is the number of positions at which the corresponding bits are different.Given two integers x and y, calculate the Hamming distance. IDEA:Integer.bitCount() 463. Island PerimeterYou are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. IDEA:THIS IS ONLY ONE ISLAND. So go throught the whole 2D-array, for every ‘1’, we check its surrounding value and calculate its perimeter, and update the how perimeter. 500 - 600513. Find Bottom Left Tree Value [Medium]Given a binary tree, find the leftmost value in the last row of the tree. IDEA:Easy BFS and push node in left to right order. Then store the val from the first out node. 561. Array Partition IGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. IDEA:greedy: sort then sum one out of every 2 numbers. 600 - 700605. Can Place FlowersSuppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1Output: True Example 2: Input: flowerbed = [1,0,0,0,1], n = 2Output: False Note: The input array won’t violate no-adjacent-flowers rule.The input array size is in the range of [1, 20000].n is a non-negative integer which won’t exceed the input array size. IDEA:TWO corner cases: the first and the end of the array. 637. Average of Levels in Binary TreeGiven a non-empty binary tree, return the average value of the nodes on each level in the form of an array. IDEA:BFS and calculate average, be careful about the result date type, int is not eligible 646. Maximum Length of Pair ChainIdea:The tag of this problem is DP but it seems like a greedy problem and I cannot figure out how to use dp to solve it? 657. Judge Route Circle [Easy]Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. IDEA:Easy, no 693. Binary Number with Alternating BitsGiven a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 Example 2: Input: 7Output: FalseExplanation:The binary representation of 7 is: 111. Example 3: Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011. Example 4: Input: 10Output: TrueExplanation:The binary representation of 10 is: 1010. IDEA: O(32) solution, check every bit n -&gt; 32-bit ‘1’ -&gt; n&amp;(n + 1) == 0 ? 698. Partition to K Equal Sum SubsetsGiven an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4Output: TrueExplanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Note: 1 &lt;= k &lt;= len(nums) &lt;= 16. 0 &lt; nums[i] &lt; 10000. IDEA:ONE OF THE MOST DISGUSTING PROBLEM:Hints : buckets. 700 - 800766. Toeplitz MatrixA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. IDEA:brute force. We have to check every elements. 800 - 900811. Subdomain Visit Count [Easy]A website domain like “discuss.leetcode.com” consists of various subdomains. At the top level, we have “com”, at the next level, we have “leetcode.com”, and at the lowest level, “discuss.leetcode.com”. When we visit a domain like “discuss.leetcode.com”, we will also visit the parent domains “leetcode.com” and “com” implicitly. Now, call a “count-paired domain” to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be “9001 discuss.leetcode.com”. We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:[“9001 discuss.leetcode.com”]Output:[“9001 discuss.leetcode.com”, “9001 leetcode.com”, “9001 com”]Explanation:We only have one website domain: “discuss.leetcode.com”. As discussed above, the subdomain “leetcode.com” and “com” will also be visited. So they will all be visited 9001 times. Example 2: Input:[“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”]Output:[“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”]Explanation:We will visit “google.mail.com” 900 times, “yahoo.com” 50 times, “intel.mail.com” once and “wiki.org” 5 times. For the subdomains, we IDEA:Easy HashMap 852. Peak Index in a Mountain ArrayLet’s call an array A a mountain if the following properties hold: A.length &gt;= 3There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]. Example 1: Input: [0,1,0]Output: 1 Example 2: Input: [0,2,1,0]Output: 1 Note: 3 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^6 A is a mountain, as defined above. IDEA:Because it is definitely a mountain, we can binary search the topest value in this array and return its index. 853. Car FleetN cars are going to the same destination along a one lane road. The destination is target miles away. Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.The distance between these two cars is ignored - they are assumed to have the same position.A car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.If a car catches up to a car fleet right at the destination point,it will still be considered as one car fleet. How many car fleets will arrive at the destination? Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]Output: 3Explanation:The cars starting at 10 and 8 become a fleet, meeting each other at 12.The car starting at 0 doesn’t catch up to any other car, so it is a fleet by itself.The cars starting at 5 and 3 become a fleet, meeting each other at 6.Note that no other cars meet these fleets before the destination, so the answer is 3. Note: 0 &lt;= N &lt;= 10 ^ 4 0 &lt; target &lt;= 10 ^ 6 0 &lt; speed[i] &lt;= 10 ^ 6 0 &lt;= position[i] &lt; target All initial positions are different. IDEA:We need to find the fleets, so we need to know if one car will catch another one. To simplify the process, we sort the original position array, let’s say in ascending sequence, then we have a new array, let’s name it pos. Then the end of pos is closest to the target and the head of pos is farest to the target.Now from the end of the array, we calculate the time that every car need to take to reach the target, if one car A firstly is ahead of car B but the time of car A need to take to reach the target is larger than B‘s time, it means that car B catches car A in no doubt, which means they are views as one car fleet.So the key of this solution is: sort position calculate the time consumption compare the time consumption from the end to the head with current time and determine the occurence of car catching. CODE 854. K-Similar StringsStrings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B. Given two anagrams A and B, return the smallest K for which A and B are K-similar. Example 1: Input: A = “ab”, B = “ba”Output: 1 Example 2: Input: A = “abc”, B = “bca”Output: 2 Example 3: Input: A = “abac”, B = “baca”Output: 2 Example 4: Input: A = “aabc”, B = “abca”Output: 2 Note: &lt;= A.length == B.length &lt;= 20 A and B contain only lowercase letters from the set {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’} IDEA:When it comes to the shortest distance or shortest of something, we need to consider BFS first. After all, it is the most common algs to solve this problem.In this problem, we use BFS to guarantee the result is shortest, then we swap every pair in A to reach B and offer (because in java queue, the func is offer()) all the results to queue then use BFS to solve it. CODE 855. Exam RoomIn an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1.When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. (Also, if no one is in the room, then the student sits at seat number 0.)Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room. It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p. Example 1: Input: [“ExamRoom”,”seat”,”seat”,”seat”,”seat”,”leave”,”seat”], [[10],[],[],[],[],[4],[]]Output: [null,0,9,4,2,null,5]Explanation:ExamRoom(10) -&gt; nullseat() -&gt; 0, no one is in the room, then the student sits at seat number 0.seat() -&gt; 9, the student sits at the last seat number 9.seat() -&gt; 4, the student sits at the last seat number 4.seat() -&gt; 2, the student sits at the last seat number 2.leave(4) -&gt; nullseat() -&gt; 5, the student​​​​​​​ sits at the last seat number 5.​​ Note: 0 &lt;= N &lt;= 10^9 ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p. IDEA:We notice that the range of N is from 0 to 10^9 so it is not wise to create an array to store every seat’s state. We can use segment to present the seat’s state and two points of a segment are both occupied.In this case, the corner case are the first seat and the last point because their segments have just one point and the other is the boundry of the array which we need pay attention to. Solution:Keyword: TreeSet, Point, Priority(Haven’t been reached, do it in few days later) CODE]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms]]></title>
    <url>%2F2018%2F05%2F09%2FAlgorithms%2F</url>
    <content type="text"><![CDATA[ALGORITHM This is how I learn algorithm. 1. Backtracking2. DP ( learning )The following link is very helpful to understand the kernel of DP and what’s dp and how to use it.MIT Dynamic Programming Normally, when it comes to brute force, it involves exponential time performance. Take subsets as an example, for every single elements, we have to decide use it or not, so for the length n, we have 2 to n possibilites which is exponential. BUT, in some problems, we can divide them into subproblems, and subproblems will always show up with recursion, in this way, we can make code clearlier and conciser. However, subproblems can be repeating, in topological way, it is said that the topological structrue is the same. So if we take no steps to avoid this or optimize the performance, the time performance is still bad.Then that is the key of Dynamic Programming, we store every subproblem’s result in memory, every time we encounter a repeating subproblem, we just use the result and apparently we reduce the time consumption down to O(1) In the former link, the lecturer has listed 5 steps to use dp to solve problems: find/define subproblems guessing, how many choices I have ( #choices ) relate subproblems ( time/subproblem) recurse and memorized / build up DP table ( total time ) solve original problem. 3. BFS &amp; DFS4. Patient Sorting ( used for LIS, Longest Increasing Sequence ) Given an array, loop through the whole array and build piles based on two rules: 1) The bigger num cannot place on a lowwer num, if none of current piles can be placed on, then create a new pile;2) keep number of piles as small as possible. To get a LIS given an array, when we have former rules, we can follow these steps:123456while ( ) &#123; 1. build pile and pointer that points to the current top element of the pile 2. whenever place a new element to a pile, update its top element and its pointer to previous pile's top elements. 3. from the rightmost element, then go back to the first pile based on the pointer value, and we will get the target LIS.&#125;]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Exercise]]></title>
    <url>%2F2018%2F05%2F06%2FLeetCode-Exercise%2F</url>
    <content type="text"><![CDATA[Leetcode This is a temporary post to record the experience of doing leetcode and will be rewrite and rearrange the layout (Typesetting) ASAP.In the future I will sum up all the algs I know to a new post and write a new post to record the exercise. Hope I can do it well2018.5.6 Updated 2018-5-9, the following days will be tough and I have to rearrange the quantity of leetcode problems. The next 2 weeks’ focus is on GRADUATTION PROJECT &amp; Side Project preparation.Fight. 2018-5-1498.Validate Binary Search TreeMy first thought is using a stack to store the BST in preorder and compare the new-to-stack element’s value a with stack.peek() = b , if a &gt; b then it is false;When I check the Discussion Section and I find a more concise way to solve it. we can use localmin and localmax to restrict the range of local element’s value, but if we want to cover the whole range of Integer we have to set the original value of localmin to Long.MIN_VALUE and localmax to Long.MAX_VALUE which is not recommanded. So we can add two more boolean variable hasMin and hasMax to indicate whether we need check the upperbound or lowerbound.1boolean isValidBST(TreeNode node, int localMin, int localMax, boolean hasMin, boolean hasMax) 111.Minimum Depth of Binary Treerecursive:compute the minimum depth of every node (left and right), especially when it comes to a situation that left or right is 0, we need to return the other side’s length, and we have a tricky code:1return (left == 0 || right == 0 ) ? left + right + 1 : Math.min(left, right) + 1; 110.Balanced Binary Treeuse the same idea of No.111 problem :compute the length of left and right subtree and compare them and return the boolean value. 257.Binary Tree Pathslike a backtracking problem.Have learned the new API of StringBuilder class:123StringBuilder sb = new StringBuilder();sb.delete(int start, int end); // delete the element from start to end - 1.sb.setLength(int length); // set the length of StringBuilder, I think this one is more convenient than the former one when it comes to deletion. 695.Max Area of IslandWith a “DFS” tag but it seems like a BFS problem.use a 2d array to record whether a position has been visited. 2018-5-10343.Integer Break很难受，没有想出DP的解决方法！！争取明天弄一下DP的方法！ 2018-5-9今天看到了一个很nice的关于DP的总结，也算是弄清楚了一点点DC,DP和greedy的关系图了。1、DP算法起源于DC，一个问题的解，可以分解为求解一系列子问题的解。同时包含有重叠子问题。这就得到了DP的第一个黄金准则：某个问题有独立的，重叠的子问题。也就是说，如果子问题不独立，没有办法分治。独立但是不重叠，直接遍历即可，也就是分治的实现。如果有重叠，那就是DP的用武之地了。2、DP算法的黄金准则2,：最优子问题。很明显，DP的本质在于不重复计算子问题，因为把其计算结果存储起来了。也就是之前说过的state。 Best Time to Buy and Sell Stock with Transaction Fee Best Time to Buy and Sell Stock with Cooldown Best Time to Buy and Sell Stock IV很难受，有了状态转移方程写不出代码。。原来之前的代码原理上没有任何问题。。。。出在了边界条件的判断失误，导致少算了一个。我说思路没问题怎么一直有问题。。！！！ Best Time to Buy and Sell Stock III 2018-5-8 Counting Bits真的很巧妙，右移一位之后，就只要判断奇偶来决定bit的个数了。虽然我和他们遍历一样，但是指令时间花费太多。。。。而且我只是找到了一个规律，却没有找到更核心简便的规律。更重要的是，没有用DP的思想。。 Best Time to Buy and Sell Stock IIGreedy 2018-5-7 Min Cost Climbing Stairs Range Sum Query - Immutable尽管是在 DP tag下面做的，但是完完全全没有往这个方向去想。。。还是brute force解决。可以利用sum，记录[0,i] 2018-4-10Array Partition IArrays.sort，是Arrays！ Max Consecutive Ones都说了是Consecutive ones还在考虑连续的0，不知道题目到底看没。 Toeplitz Matrix关键是对角，不一定要分组的。 Move Zeroes又是低级错误。。。。数组数值被下标代替。。。。 week 51In in = new In(args[0]); &amp;&amp;语句前后顺序很重要！12345if( x.lb != null &amp;&amp; rect.intersects(x.lb.rect) ) // the upper and the lower act the sameif( x.lb != null )&#123; if(rect.intersects(x.lb.rect)&#125; 所以一旦反过来变成这样就会出问题，因为x.lb可能为Null1rect.intersects(x.lb.rect) &amp;&amp; x.lb != null nearest 是x.lb或者x.rt的rect的判断而不是对x.rect的判断 2018-4-11今天看了两个算法:BFS ： Breadth-First-SearchDFS： Deapth-First-Search BFS: 采用FIFO结构 顶点进队列while（队列非空）{ 把周围的未经过的顶点进队列。 出队列。}结束循环，遍历所有节点。 DFS：栈 先把所有节点标白顶点进栈，将其标灰while(栈非空）{ if（邻节点有白）{ 节点标灰色 进入节点，将其压栈。 } else （邻节点无白）{ 将该点出栈 } } 2018-4-16现在准备看KMP算法，在回文算法题的discussion中看到。、 2018-4-17复习week1 内容，Topological sort是redraw DAG so all edge point upwards.1) DFS, 2) return vertex in postorder 脑子不清醒了：1、数组元素居然用 [ ] 括起来；2、数组长度是num.length不是num.length{}3、二分法的判断条件是high &gt;= low，有一个等于号！！！ ① 167. Two Sum II - Input array is sortedsort 二分法还是不如两头相加来的方便。两头相加真是太牛逼了。要注意的几个点是 int相加溢出，用long存储。判断参数。 ② 169. Majority Element自己第一反应是简单粗暴的创建一个65536数组，直接存储，两次for进行brute serach想想有没有更好的方法看了discussion：1、牛逼，充分利用了major element数量大于一半，直接对数计数，遇到就加，碰到就减，最后留下来的肯定是major element2、bit操作，很神奇。但是不知道为什么能够得到正确的结果。3、hash table，暂时没学过，明天学习。4、sorting，直接获取中间位数字即可 ③ 448. Find All Numbers Disappeared in an Array第一反应： sort之后，根据offset计算disappear的值看了discussion：1、利用数组元素作为索引标记。核心在于数组中的元素个数和最大的数是相同的，也就是都是n。我之前以为可以小于n所以一直觉得很有问题。重点还是要好好审题啊。总是有小问题。得到思路之后自己写，又出现了小问题：写出了List。。。emmm多注意小细节。 提交之后发现有时间更短的，果然用了额外数组空间。 ④ 717. 1-bit and 2-bit Characters很简答的一道题目。。。emmm就是低级错误还是有:1、变量都没声明就开始用了。2、if语句乱用 。。。3、大思路正确但是细节方面还是有瑕疵，跳跃检查没事但是忽略了最终都会跳到同一个位置。。 ⑤ 121. Best Time to Buy and Sell Stock思路很清晰的一道题目，但是自己还是考虑不够。1、先入为主，没有考虑多种可能，认为只有一种可能，所以直接判断左边最小和右边最大。致使[2,4,1]这种testcase都output = 0，（因为左边最小是1所以 1 - 1 = 0） 刚刚看了 Best Time to Buy and Sell Stock II，听说要用贪心算法，没有接触过，明天对其进行了解。 2018-4-18① 128. Longest Consecutive Sequence (有问题，没有达到O(n) 的要求却AC 100)要求O(N)，所以第一反应就是sort之后直接go through，O(n)+O(nlogn),不知道这算不算O(n)….数量级上是一样的。提交后居然第一次AC 100，卧槽。。。。尽管如此，第一次提交忽略的一个corner case，就是都是consecutive的时候，就不会执行到else语句当中。这个要多注意。★ if-else语句要注意是否都会执行到。 ② 217. Contains Duplicatesort之后直接判断。发现自己已经迷上了sort【然而好像时间复杂度。。。。】 ③ 268. Missing Numbersort之后 go through或者二分查找 看了discussion发现，有两个灵性的解法，但是比较特殊，因为只能找到少一个的1、SUM操作，然后减array2、XOR操作，因为a^b^b = a，所以将1 ~ n 所有与array中的所有XOR，就能得到missing number ④ 661. Image Smoother第一反应还是brute 解决。看完discussion，似乎大多也是brute。但是有一个厉害的老哥，利用了255是8bit，int是16bit，将前8bit作为计算结果存储，最后整体右移8位！！！强的一笔，节约了一倍的空间。反思：1、自己边界判断都能弄错，服了。真是不知道在干嘛。。。。2、循环变量居然忘记初始化？？？？ ⑤ 628. Maximum Product of Three Numbers很奇怪，为什么sort之后直接计算的速率还不如不算的速率？因为时间复杂度不同。 ⑥ 746. Min Cost Climbing Stairsgo through, i处判断i+1, i+2 第一次提交出错，[0,0,0,0]很玄学，因为判断顺序的问题，先进行了计算后进行了判断，所以先出界，然后判断。抛出异常第二次提交出错，[0,2,2,1]改成两头运算，但是感觉很虚，方法冗长。 思路完全错误，应该动态规划。贪心算法似乎有问题。还是没有搞懂贪心算法和动态规划的区别。这道题目先放一放吧。把这两个算法弄懂了再来做。 ⑦ 697. Degree of an Array思路:go through array, 统计value（degree），first_index，last_index然后计算degree，和minimum_length时间复杂度go through – O(n) 统计，链表的话就是O(n), hashmap/hashtable 是 O(1)计算degree， go through O(n) 引出hashmap和hashtable的区别问题。 重新规划，先刷1-300. Two Sum失去了sorted这个条件就只会brute解决了，看了大神的解答发现可以用HashMap，可以尝试一下用HashMap解决。 Add Two Numberseasy,设置res和carry两个数分别记录加后%10的值和进位，然后判断l1,l2是否为同时为null为结束循环条件。但是忽略了同时为null时也有可能carry = 1，导致错误。同时计算res加了c，计算c的时候却没有，同样导致错误。多加小心。 Longest Substring Without Repeating Characters两个index，一个头一个尾，hashmap存储，一旦tail发现重复，回溯到重复点，重新查找，并且保存当前maxlen思路正确，但是很遗憾，代码编写错误还是很多。值得注意的是1、s.length() 和 a.length String的length是带括号的，而数组不带。2、找s中对应下标的char是s.charAt(index),而数组直接a[index]即可3、|原始类型|封装类||:—|:—-||boolean| Boolean||char | Character||byte | Byte||short | Short||int | Integer||long | Long||float | Float||double | Double|4、遇见if-else一定要多加注意，看有没有可能一直if或者一直else导致某些特定语句没有执行到。。。。 2018-4-20 Reverse Integer第一反应，boolean sign保留符号，然后abs计算，改成string，逆序，改回long int，输出。还是太复杂了，直接从尾部go through，但是overflow有一个很奇妙的地方，x / 10 != a即可证明其overflow（https://leetcode.com/problems/reverse-integer/discuss/4060/My-accepted-15-lines-of-code-for-Java/126400?page=1）java int是32bit Palindrome Number和7一样计算出值直接 ==，而且如果入参 &lt;0 直接返回false Roman to Integer找最大值，然后go through，小于最大的index做减法，大于的做加法。仍然有漏洞，最大的可能多次出现。且多次出现仅有可能在头部。 Merge Two Sorted Lists题目根本没有说要保持sorted。。。改了之后过了 Valid Parentheses利用stack，检查。但是时间花费较多，似乎用数组更快，这是为什么呢？ Divide Two Integers (Medium)这种数据的edge case一定有overflow！！！！java中 int cannot be converted to boolean 2018-4-21 （29今天也把他弄懂。） Count and Say递归计算，时间开销很大。学习其他人的方法。1、利用循环调用函数进行计算，能用循环尽量用循环，因为递归在不断开销新的资源，每一次调用都会产生新的资源，而循环能够尽量再同一空间上进行计算，能够减少资源的开销。2、char[] 与 String之间的变化，String有个toCharArray()变成char数组，所以没必要每次都用s.charAt(index)来读取char3、新学到StringBuilder类4、数组长度length，字符串长度length()5、改为循环，仍然没有利用StringBuilder，发现时间开销依旧很大，改为Stringbuilder之后瞬间提升，原因是什么呢？这是因为String的长度大小是不可变的，当我们进行拼接的时候重新创建了一个新的String类型数据，所以不断的循环导致不断的开销。而StringBuilder的长度是可变的，所以一直在同一个内存空间操作，速度大大提升。如下图所示 String 长度大小不可变StringBuffer 和 StringBuilder 长度可变StringBuffer 线程安全 StringBuilder 线程不安全StringBuilder 速度快 Search Insert Positioneasy binary search Remove Duplicates from Sorted Arrayeasy index increase to go through. duplicates is invalid and can be overwrited Remove Elementsame way as 26 but no need to check index == len - 1. just record the number of deleted elements. Divide Two Integers (Medium)采用brute方法直接exceed time limit,很难受。看看别人怎么做的吧1、擦，被秒杀。。。这个bit 操作真的很骚。。。而且我记得之前也有一道题目涉及到了bit操作。2、其实对divisor进行自加加然后对其结果再次自加，也有移位的效果。所以其实就是耍了一个trick，说不能用乘除和mod，就利用移位达到快速定位的效果，这个其实也相当于 go through和二分的区别。 Roman to Integer右有大，负加。右无大（碰边界），正加。思路完全正确，之前居然没有想到。但是发现了新的问题：Java中 Hashmap性能上似乎不如switch语句，原因暂时不知道，只看到了几个关键词：JVM, tableswitch, Lookupswitch, HashMap自己的构造函数中默认构造大小。 Longest Common Prefix其实是一道没有太大意思的题目，思路清晰，仅仅锻炼一下自己码代码的细节的问题：1、charAt是函数，用的（）括号而不是 []2、char[][] 是不存在的。只有char[]3、一定要注意自己的for循环里面，是否将 i 写成了常数 2018-4-21 Median of Two Sorted Arrays（）要求是log(m+n)重点是弄懂median的作用，其作用是分割成两个部分，左边最大小于右边最小。且左右大小相等。所以基于这个亮点对其中一个进行binarysearch，然后另外一个因为要保持大小相同，所以也在同时binarysearch，达到log的效果。尽管如此，原理还是没有完全弄透彻。Hard果然是Hard。。。需要反复复习。 Maximum Subarray直接遍历整个数组，从第一个大于0开始，sum进行累加，if sum &gt;= 0 i++,maxsum = Math.max( maxsum, sum),else sum &lt; 0, i++, sum = 0; maxsum = Math.max ( maxsum, sum);O(n) 时间复杂度。说可以用分治的方法 divide and conquer, 开始学习怎么做。如果按照我刚刚从大于0的开始，要出问题。因为可能全为负值，导致出错。思路还是正确的，看完讨论发现大家都是O(n)的时间复杂度。我的思路上是遍历，但是用到了分治的思想，但是自己没有看出来。分：i 遍历，寻找前 i 个sum最大的。治：根据第 i - 1 个情况，若小于0，清零计算，大于0，不作改动。然后加nums[i],然后与前一时刻最大值比较。其实这里sum 相当于状态，maxsum就是历史。 Length of Last Word Plus One Sqrt(x)耍了一个trick，直接从Integer.MAX_VALUE的平方根开始算。 Climbing Stairs Remove Duplicates from Sorted Listeasy，但是实现过程中还是有小问题：1、没有判断是否相同直接跳到下一个节点导致：【1,1,1,1,1】处理完变成了【1,1,1】。因为第二个处理完之后跳到了第三个，处理完第四个跳到第五个。。。。 Merge Sorted Array虽然不可以从最小的开始，但我们可以从最大的开始啊。 Add BinaryStringBuilder 可以append不同类型的，不一定要char型。而且可以不同类型组合。 Maximum Depth of Binary Tree Same Tree Single Number这个还是简单的，毕竟两个相同的数字进行异或即可。 Single Number II这个就很难受了，弄了一个晚上。感受到了自己的菜鸡。利用状态转移，设置不同状态表示接收到了不同的bit个数，因为某一个，数字的固定位置比特肯定是只出现一次的。所以只要弄一个只有固定比特为1的状态，其余以方便优先选择。 Single Number III位运算，求反，本来和原来的数完全相对，相与变成0，但是加1之后，能够找到最右不同的比特，也可以说从低到高第一个不同的bit解释如下： 12345678 s1 a1 b1 c1 s2 a2 b2 c2^ ————— s a b c// NOT s_ a_ b_ c_ ————— ①c = 1,说明c1 c2 不同②c = 0,说明c1，c2相同，则c_ = 1，③+1之后，将进位，也就等同于+1到b，继续①②两步 after find the rightest bit, then we diff &amp; -diff, we can make the bits lower than the rightest bit to zero, the rightest will be ‘1’ and those bits higher than the rightest will be ‘0’ because of ~ operation Integer to Romaneasy Integer to English Wordseasy ZigZag Conversion找规律题目 Generate Parenthesesbacktracking题目，但是属于easy的范围，仍然没有完全弄懂backtracking的原理，明天可以找backtracking题目进行熟悉。 Valid Palindromeeasy，没有太刁难。首尾移动判断即可。 Valid Palindrome II多了一个简单的判断。 Path Sum思路还是很清晰的，但是在代码实现过程仍然要注意几个问题：1、参数可以是null，但是不能对null进行操作，所以在对参数进行操作时要注意是否为null，尤其当对多个参数进行判断的时候。因为自己总是仅判断一个情况，那就是全为null的情况。 Symmetric Tree这里居然出现了一个低级错误——对节点本身进行判断，而不是其中的值。。。 2018-4-29 Linked List Cycle可以利用head作为标志，全部指向head，如果有一个节点已经指向了head说明了有loop，但是这样会破坏原来的数据结构。若要copy古来又无法满足without using extra space2、brilliant，利用walker和runner，一个走一步一个走两步，如果loop肯定能相遇，如果到了末端没相遇则没有！ Letter Case Permutationbacktrack 练习题，慢慢摸到了一点点门路。现在对其理解就是建立一个helper用于递归调用: 12345678910111213helper(...)&#123; if ( i &lt; len )&#123; if(isValid) go left; some operations; go right; else back to i-1(return ) &#125; else&#123; store; return; &#125;&#125; Linked List Cycle II 很遗憾，自己的方法还是不如别人的方法。 l1 = the distance from head to the node where cycle beginsl2 = the distance from the node where cycle begins to the node where walker and runner meetl3 = the distance from the node where walker and runner meet to the node where cycle begins.when first meet, we havel1+l2 = (l1+l2+l3+l2) / 2, because the time used is the sameso l1 = l3. Permutations也算是知道了自己的错误了。思路没有错误，但是数据处理上出现了问题，因为lastres是重复使用的，当我add的时候一直加的同一个地址，所以最后在remove掉的时候把lastres所对应的空间数据全部remove掉导致没有任何数据了。 Letter Combinations of a Phone Number Permutations II感觉很有代表性的一道题目，做出了这个题目之后其他的duplicate几乎有迎刃而解了。 Subsets Combinations Combination Sum Combination Sum II Combination Sum III Beautiful Arrangement真的很强，从头遍历和从尾部遍历得到不同的branch，而从尾部能够更快的过滤掉无用的东西。难怪是medium。 2018-5-2 Rotate Image思路清晰，但是代码编写上还有漏洞，比如内外循环变量，内 j 外 i应该是i &lt;= len/2 写成了 i &lt; len/2，而且 j也写成了 j &lt; len/2，本应该是 j &lt; len-1-i。。。。emmm这个问题的出现，主要还是自己从思路到代码方向上不能够有效的联系起来。1、首先采用递归123456789101112131415161718192021222324/*** Definition for singly-linked list.* public class ListNode &#123;* int val;* ListNode next;* ListNode(int x) &#123; val = x; &#125;* &#125;*/class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if ( head == null ) return null; ListNode Head = new ListNode(0); Head.next = head; swap(Head, head, head.next); return Head.next; &#125; public void swap(ListNode head, ListNode node1, ListNode node2)&#123; if ( node1 == null || node2 == null ) return; node1.next= node2.next; node2.next = node1; head.next = node2; swap(node1, node1.next, node1.next.next); &#125;&#125; 知道问题在哪里了，当node1.next已经是null的时候，node.next.next就要出问题了，因为null是没有next的，此时就会爆出NPE错误。更改后如下：12345678910111213141516171819202122class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if ( head == null ) return null; ListNode Head = new ListNode(0); Head.next = head; if ( head.next == null ) return; swap(Head, head, head.next); return Head.next; &#125; public void swap(ListNode head, ListNode node1, ListNode node2)&#123; node1.next= node2.next; node2.next = node1; head.next = node2; if ( node1.next == null || node1.next.next == null ) return; swap(node1, node1.next, node1.next.next); &#125;&#125;when( lo &lt; hi)&#123; mid = (lo+hi) / 2; if ( nums[mid] &lt; nums[low] ) high = mid - 1; else low = mid;&#125; Swap Nodes in Pairs1、函数可以接受null参数。2、不能对null参数进行操作——也就是说，在链表中，head.next = null时，不能调用head.next.next；否则就是NPE错误。很关键。所以这个决定了是进了函数体之后再做判断，还是先判断再进函数体。 Remove Nth Node From End of List保留头部，以n长度窗口移动，到tail时铲除head.next； Search in Rotated Sorted Array很难受，其实思路一样，但是代码就是写着有问题。讲道理的话，找到最大值和找到最小值进行计算都一样。但是为什么最大值就无法正确的找到呢。。。！！！！！！很有意思的一道题目，帮我解决了BS的核心问题。a_lo, a_mid, a_hi。前面之所以找最大值不能够正确的找到，问题出在最后一步。因为二分法无论如何最后总会变成a_lo = a_mid， a_hi.此时如果采用寻找最大值，就无法满足a_lo和a_mid是独立开的，导致之前一直依赖的逻辑出错。（因为不再满足这个逻辑）而如果是采用寻找最小值，就能够满足a_mid和a_high是独立开的，最终找到正确的值！！总结为两点：1、选择mid与high比较，不可选择mid与low比较2、此时因为low high 有可能等于mid，若循环判断条件为 low &lt;= high会出现 low一直等于high的死循环，应该改为low &lt; high Search for a Range先二分找到一个值，再在其左右二分寻找（是否需要左右寻找通过一个简单的左右值判断即可） Multiply Strings也算比较蛋疼的一个题目吧，主要还是一些corner case的考虑不够周全。1、没考虑到”0”2、学到了String之间比较如果直接 ==比较是引用比较，比较的是地址，要比较内容需要用到equal函数 2018-5-3 Rotate List又是一道rotate的题目，可以利用rotation的特性直接得到newhead和newtail的位置。但是要留一个HEAD定位真正的头的位置。 Reverse String学到了String.valueOf() 1234567891011121314class Solution &#123; public String reverseString(String s) &#123; char[] c = s.toCharArray(); int l = c.length-1; int mid = (l+1)/2; char t; for(int i=0; i&lt;mid; i++)&#123; t = c[i]; c[i] = c[l-i]; c[l-i] = t; &#125; return String.valueOf(c); &#125;&#125; 2018-5-4 Reverse Words in a String III两个新函数需要学习：String下的split，StringBuilder下的trim() 2018-5-4 Number of 1 Bits学到了一个小技巧。。。 “&gt;&gt;&gt;”是logic shift Reverse Bits思路没错。。。然而没想到是32bit，只做了有效位的reverse，高位的0刚刚开始没有reverse Power of Two 2018-5-5 Min Stack我是按照之前coursera里面做的啊，为什么时间效率这么低，可能是数组空间变化的原因，但是原Java里面的Stack类不是吗？待会了解一下； Factorial Trailing Zeroes自己总是陷入brute force的思路，很难受。。。但是自己想到了5，没有仔细的深挖，或者说自己境界不够吧，居然在想着怎么凑2和5来算10的个数。。。其实只要看5就行了。 Rotate Arrayfor those elements in the range of [n-k, n-1], they need to move to (i+k) % n, and when i+k is in the range of [n, 2n), we have (i+k) % n = i+k-n;for those elements in the range [0, n-k-1], they need just move to (i+k)like below: 12345670 n-k-1 n-k n-1[ | ] a1 range1 range2Thus, when we first reverse the whole array, we have the ist element in the new array which equals n-i-1, and now we have0 k-1 k n-1[ | ] a2 range2 range1 so when we reverse the first part of the new array a2(range2), the ist element in the new array part will be k-1-(n-i-1) = k+i-n and this is exactly what we need, the same as the second part after the reversion. House Robbereasy DP solution but used O(N) space; it seems like there is a O(1) Space solution 2018-5-6 Container With Most Water 123456while(left &lt; right)&#123; if nums_left &lt; nums_right left++; else right-- update max&#125;return max; Remove Duplicates from Sorted Array IIif-else problem happens again, when it comes to if-else branches, YOU NEED TO CHECK IF THE CORNER CASE THAT ONLY IF OR ELSE BRANCH IS APPROACHED. K-diff Pairs in an ArrayI do it by simple search like brute solution.However, there are some more efficient solutions like Two Pointers or HashMap, the latter is more understandable but the former is a little hard to understand fully 123456789101112131415class Solution &#123; public int findPairs(int[] nums, int k) &#123; if(k &lt; 0) return 0; int cnt = 0; Arrays.sort(nums); for(int i = 0, j = 1; j &lt; nums.length; )&#123; if(i &gt;= j || nums[i] + k &gt; nums[j]) j++; else if( i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] || nums[i] + k &lt; nums[j]) i++; else&#123; cnt++; i++; &#125; &#125; return cnt; &#125;&#125; Figure it out but don’t know how to come up with the idea. Minimum Size Subarray Sumtwo pointer i and j, sum to store the sum of subarray 12345678910for i,j = 0; j &lt;= nums.length;if ( sum &gt;= s ) &#123; update minlen; sum -= nums[i]; i++; &#125;else&#123; if( j == nums.length ) break; // j comes to the end and the increment of i will never enlarge the sum. so break; sum += nums[j]; j++;&#125; Sort Colorssomeone posted four different solution…omg…What a hugeMy idea:sort 0 then sort 1. two pass.don’t know the one pass solution…① Insertion solutionExplanation: restore the last index of 0, 1, 2 and when it comes a new num, we insert it and increment the corresponding index, eg insert 0, increase index of 0,1,2 but if insert 2 we only need to increase the index of 2.n0,n1,n2 12345678for( i from 0 to nums.length)&#123; if nums[i] = 0 nums[++n2] = 2; nums[++n1] = 1; nums[++n0] = 0 else if else &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
