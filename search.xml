<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019Fall_New_Grad_Exp]]></title>
    <url>%2F2019%2F12%2F27%2F2019Fall-New-Grad-Exp%2F</url>
    <content type="text"><![CDATA[先挖坑，年后填]]></content>
  </entry>
  <entry>
    <title><![CDATA[每日一学]]></title>
    <url>%2F2019%2F12%2F26%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[总要学点新的东西，每天看看自己不懂或者懂的东西也是极好的。 2019-12-28 记一次绕过后缀名限制的文件上传 https://thief.one/2019/10/14/1/ 2019-12-27 Docker &amp; Kata Container 摘自 https://1o24bbs.com/t/topic/19489 2019 年 11 月 13 日，私有云基础设施公司 Mirantis 在其官方博客宣布，收购 Docker 公司企业级业务，包括接管它的 700 多个客户，这标志着 Docker 公司从 2013 年开始的商业化探索彻底失败。 “Docker 自身的技术路线，无法很好地解决安全问题”，这是为什么呢，通过文章来看似乎只是一个额外隔离层的问题。为什么Docker就做不到呢，是根本就没往这个方面做还是由于某些原因导致无法这么做呢？ 2019-12-26 SASE 摘自知乎：https://zhuanlan.zhihu.com/p/96146804 云服务和网络正在推动数字业务的概念，但是传统的网络和网络安全架构远远不能满足数字业务的需求。 Gartner的“ 网络安全的未来在云端 ”报告阐明了在新的网络和安全模型的基础上进行云网络和安全转型的潜力，该模型称为安全访问服务边缘（SASE）。 传统网络及网络安全架构，是为企业数据中心即用户和设备访问所需实体中心而设计的。此前这一模型效果不错，但数字化转型催生了一些新的要求。 随着企业纷纷拥抱数字业务过程，以及边缘计算、云服务和混合网络的兴起，传统网络和安全架构开始多方崩塌的迹象越来越明显。 传统架构的整体复杂性带来了问题，例如延迟、网络盲点、过多的管理开销以及随着服务变化而不断进行重新配置的需求。通过降低网络复杂度和将安全过程迁移至可发挥最大效用的网络边缘，SASE 模型摒除了这些问题。 下面将从网络架构的角度来剖析SASE的特点。 复杂性和开销 传统的机制受到客户站点物理设备硬件容量的限制。这种机制导致硬件更新率的滞后，而这些硬件也是添加新功能所必需的。 基于硬件的网络和安全解决方案内置在硬件中，这种方式可以加速服务并添加新功能。但有些功能只在特定的硬件上可用，而不是在您本地的硬件上。在这种情况下，客户有繁重的部署工作。 随着环境的发展，我们不应依赖于新一代设备带来的新网络和安全功能。通常，此模型效率低下且复杂。它带来了高昂的运营开销和管理复杂性。 新功能的设备升级需要大量的管理。从过去的经验来看，更换一张线路卡需要多个团队的参与。有的线路卡可能没有端口，或者您可能只需要添加一些附加功能。仅这些操作将涉及到项目规划、现场工程师、设计指南、线路卡测试等方面。为了确保关键站点成功刷新，可能需要更多的维护人员。 SASE——轻松管理 基于云的SASE支持新功能和功能的更新，无需在客户端部署新的设备（物理或虚拟）和软件版本。这对管理的便利性有直接的影响。 现在，无需接触企业网络就可以进行网络和安全部署。这使企业可以迅速采用新功能。一旦消除了功能与客户设备之间的紧密联系，就可以提高网络和安全服务部署的敏捷性和简便性。 在SASE平台上，当我们创建一个对象（比如网络域中的策略）时，它也可以在其他域中使用。因此，无论网络位置如何，分配给用户的任何策略都将绑定到该用户。这显著地消除了管理跨多个位置、用户和设备类型的网络和安全策略的复杂性。最重要的是，所有这些都可以在一个平台上完成。 此外，当我们研究安全解决方案时，许多人购买的是只专注于一项工作的个人设备。要进行故障排除，您需要收集信息，例如每个设备的日志。这就是SIEM（安全信息和事件管理）有用的地方，但是它只能在某些组织中使用，因为SIEM技术是资源密集型工具，需要经验丰富的人员来实现。对于那些没有足够资源的人来说，这个过程是非常艰难的，可能会出现错误的结果。 最后，由于所有数据都在一个公共存储库中，因此SASE使得故障排除更加容易。您不再需要对来自不同设备/解决方案的数据进行规范化，然后将数据导入数据库以获取通用视图。 供应商和技术栈的合并 安全是网络领域的一个重要话题，目前市场上存在的众多安全解决方案都很昂贵，且没有固定的价格，SASE的出现给安全领域注入了新的力量。通过将服务整合到单个提供商中，最终用户设备上的供应商和代理商/客户数量将会减少。 总体而言，供应商和技术栈的合并可以减少大量的复杂性，将复杂性从本地企业网络转移到云端，并降低了成本。 从硬件的角度来看：为了实现规模和增加容量，基于云的SASE可以添加更多PoP点。此外，基于SASE的云还负责加密处理。例如，由于现在互联网流量的很大一部分都是加密的，恶意软件可以使用加密来逃避和隐藏检测，借助SASE，每个PoP都可以对经过TLS加密的流量执行DPI。 传统防火墙无法检查加密的流量。对TLS加密的流量执行DPI将需要额外的模块或新的设备。SASE解决方案可确保在PoP上完成解密和检查。因此，在客户站点不会影响性能，也不需要新设备。 提高性能 网络拥塞导致的丢包和无序数据包对应用程序的影响非常大。数据包丢失会严重影响延迟敏感的应用程序（如视频、VoIP和Web会议）。目前有一些方案可以最大程度地减少延迟和数据包丢失带来的影响。 SD-WAN解决方案具有广域网优化功能，可以应用于不同的应用程序或不同的站点。除了WAN优化功能外，还可以使用协议和应用程序加速技术。 除了现有的减少数据包丢失和延迟的技术外，我们还可以尽可能地将广域网私有化。通过使用由PoP组成的全球主干网进行私有化，你可以控制最后一公里对应用程序产生的不利影响。 一旦私有化，我们就可以更好地控制流量路径、数据包丢失和延迟。私有网络结构是SASE的主要优势，它可以提高应用程序的性能。 SASE PoP优化 SASE基于云的解决方案中的每个PoP都在最合理的地方进行了优化，而不仅仅是在WAN边缘。在骨干网中，我们进行了全局路由优化，以确定当前哪个路径是最佳路径，并且还可以针对所有流量或某些应用程序更改该路径。 这些路由算法考虑了性能指标，例如延迟，数据包丢失和抖动，有助于为每个网络数据包选择最优路由。WAN骨干网不断分析并尝试提高性能。这与Internet路由不同，后者偏向于成本而不是性能。 随着一切都私有化，我们拥有所有信息来创建最大的数据包，并使用基于速率的算法，而不是传统的基于损耗的算法。因此，用户无需学习任何内容，就可以维持端到端的吞吐量。 由于每个PoP都充当TCP代理服务器，因此，TCP客户端和服务器的距离会更近，并且拥有更大的TCP窗口，从而允许在等待确认之前传递更多数据。 首选出口点 我们还可以定义首选出口点以退出云应用程序流量。这些可能是最接近客户应用程序实例的点。最优的全局路由算法确定了从世界任何地方到客户的云应用程序实例的最佳路径。 PoP可以放置在数据中心，为访问Amazon AWS、Microsoft Azure和谷歌云服务提供了良好的入口。用户可以在大多数时间内将流量保留在私有云上。Internet仅用于向SASE结构提供一个短跃点。 安全 SASE将网络和安全整合到一个平台中。这允许将多个安全解决方案集成到云服务中，从而在所有公司位置、用户和数据之间实施统一策略。 SASE采用零信任原则，零信任的初始路径首先要确定网络访问是基于用户、设备和应用程序的身份。它不基于IP地址或设备的物理位置。 用户/设备的身份必须反映业务环境，而不是同与上层完全脱节的二进制结构相关联。这将身份与网络世界绑定在一起，是执行策略的最佳方式。通过这种方式，可以消除对IP或应用程序的依赖。无论用户/设备位于何处，都可以一致地应用该策略。同时，可以将用户/设备/服务的身份纳入所应用的策略中。 SASE堆栈基于身份和上下文动态应用，同时在云中的战略要点提供零信任。这就是加强以身份为中心的边界的原因。]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tips]]></title>
    <url>%2F2019%2F04%2F25%2FTips%2F</url>
    <content type="text"><![CDATA[Here are some tips for the errors and other issues I’ve encountered during my study road~ Hope it helps. 😊 [TOC] SSH beautify After ssh to our school’s server murphy, the appearance is go gross that I cannot bear anymore. So I am ready to make it like my own terminal. I copied my .oh-my-zsh directory and .zshrc configuration file into my remote server. Then when I change me shell to zsh, it stuck. My friend told me it is because git will scan all the file in the server(I really don’t know why git will do this and don’t know if it is true that git really will do this). So I deleted all git-related plugin in my .oh-my-zsh directory (rm -rf git*). I disabled all git related thing in my theme file (You can find it in .oh-my-zsh/themes/$ZSH_THEMES_zsh.theme). I comment all git-related plugin in my user configuration file (.zshrc) which is git, auto jump. Then when I run zsh in my remote server, the feeling of coming home is there. 😃 2019-4-25 I cannot bear the uncolored ssh terminal anymore especially that no color when I enter git status which makes it hard for me to see the report. So I google it and find it can be solved by enter git config color.status always Another happy thing: I’ve received the updated information from my intern company. Real world seems not that friendly. 😮 😃 2019-5-9 Github issues ‘invalid username or password’ When I try to help Michael to git push the local repo to the remote server, the terminal prompts out the error message: 12error: invalid username or passwordfatal error: Autentication failed to ... I search out all information about fatal error but seems nothing helps, then I notice that I have not 2FV but Mike has. So I try to cancel this property of Mike but then I realize that it is a personal settings. So I search something about it and then find this url: https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line. Issue solved. -] 2019-5-1 AND I FINALLY RECEIVE MY NEW AIRPODS!!! Shell script Hexo Configs &amp; Frequent Problems Here are some useful configurations for hexo. beautify the article with shadow 1234567891011/* path:themes/next/source/css/_custom/custom.styl */.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;/*Get from: https://www.jianshu.com/p/d34e9531cfce*/ Avatar rotation 12345678910111213141516171819202122232425262728/* path:themes/next/source/css/_custom/custom.styl */.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(0.9); moz-transform: rotate(360deg) scale(0.9); ms-transform: rotate(360deg) scale(0.9); transform: rotate(360deg) scale(0.9);&#125;/* end *//*Get from: https://www.jianshu.com/p/d34e9531cfce*/ Social icons don’t appear 1234567891011social: GitHub: https://github.com/TCoherence || github E-Mail: mailto:hanzhiyang2019@gmail.com || envelope #Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yang_hanzhi || twitter FB Page: https://www.facebook.com/profile.php?id=100025563873836 || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype The final code should be something like this. ‘social’ cannot be commented out. Insert an image in a post ![](/images/image.jpg) ![](image.jpg)(need to set past_asset_folder attribute to true in _config.yml) 给文章添加 TOC xcrun error: path error 123456789If you are facing an error like that on new MacOS version.xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrunIt means that you need to install XCode command line, open a Terminal and run this command:$ xcode-select --installfrom: https://gist.github.com/gaquino/87bdf0e6e852e445c0489379d3e9732a link to another post on hexo xv6-the-first-process first xv6-the-first-process is the name of your post and the second one is the link name for your post. 添加comment（gitalk, disqus, valine,最终选择了gitalk） 主要参考：https://asdfv1929.github.io/2018/01/20/gitalk/ issue1: Error: Not found 似乎是需要一点时间来完成配置。 issue2: Related Issues not found Please contact @TCoherence to initialize the comment 似乎是next主题版本的原因，目前版本是，如何升级到v6.0.0呢 升级成功，但是comment仍然有问题]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xv6 the first process]]></title>
    <url>%2F2019%2F04%2F19%2Fxv6-the-first-process%2F</url>
    <content type="text"><![CDATA[This is the summary after I read doc of xv6, source code of xv6 and other reference. At the end of the article I will present all reference I read. [TOC] 0. Introduction It is so IMPORTANT for us to know how actually a system is loaded from the start and how the first process is executed. We all know about system calls from the user process, but what operations are executed by OS, we still don’t know. So here I want to walk through roughly procedures from how a system is loaded to what it is like when the first process is executed. 1. BIOS &amp; Bootloader 1.1 BIOS It is necessary to know that when we plug in the power, our computer will load BIOS and start self checking. Because at first we are in real mode, so we only have 20-bit addressable memory to access which is 1MB. Now CS:IP = 0xf000:0xfff0. The first instruction of BIOS is to load MBR(512KB) to 0x7c00. Then BIOS will change CS:IP to 0x0000:0x7c00. From now on, our OS is ready to take over this computer and do his work! (But the real world is more complicate, no worry, we don’t care now.) 1.2 Bootloader Now we have our bootloader loaded, what we gonna do now? Let’s take a look about the source code. 12345678910111213141516171819202122232425start: # WE WILL SEE THIS IN THE END cli # BIOS enabled interrupts; disable # Zero data segment registers DS, ES, and SS. xorw %ax,%ax # Set %ax to zero movw %ax,%ds # -&gt; Data Segment movw %ax,%es # -&gt; Extra Segment movw %ax,%ss # -&gt; Stack Segment # Physical address line A20 is tied to zero so that the first PCs # with 2 MB would run software that assumed 1 MB. Undo that.seta20.1: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.1 movb $0xd1,%al # 0xd1 -&gt; port 0x64 outb %al,$0x64seta20.2: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.2 movb $0xdf,%al # 0xdf -&gt; port 0x60 outb %al,$0x60 We first disable interrupt and zero previous data segment registers and other related registers. Then we ENABLE A20. Why we do this? Because now we are in real mode, the ability of addressing is 20-bit address, we need to break this! let’s see the world of 32-bit addressing! So we send 2 binary code to the computer to enable A20. From now on, we are going to see the world of 32-bit addressing. But here is a problem, in real mode, CS and IP is combined to find the physical address, which we call this is segment address. But now in 32-bit addressing world, or even 64-bit address world, it is so hard for CS and IP to do this. So we come up with another way to do that, let’s call CS register a segment selector and let the value lies in CS register to tell me where to find linear address(Why not physical address? Because there is still another obstacle to overcome to get the real address, that’s virtual memory part, we don’t talk about that.). Here is a typical 16-bit CS register format: 123+---------------------------------------------+| index(13 bits) | T1(1 bit) | RPL(2) |+---------------------------------------------+ Index is the offset of where-to-find-linear-address table. And the so-called where-to-find-linear-address is actually stored in GDTR, or LDTR. That’s why we need T1 to help us to know which one we need to go. As for RPL, it is about priority, we don’t care for now. So we need to build GDT, that’s what we do next. Here is the code: 123456789101112131415161718192021 # Switch from real to protected mode. Use a bootstrap GDT that makes # virtual addresses map directly to physical addresses so that the # effective memory map doesn&apos;t change during the transition. lgdt gdtdesc movl %cr0, %eax orl $CR0_PE, %eax movl %eax, %cr0 .... .... # Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: SEG_NULLASM # null seg SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) # code seg SEG_ASM(STA_W, 0x0, 0xffffffff) # data seggdtdesc: .word (gdtdesc - gdt - 1) # sizeof(gdt) - 1 .long gdt # address gdt It is just a temporary GDT used for bootloader. Then let’s go to the 32-bit world. 1234567891011121314151617 ljmp $(SEG_KCODE&lt;&lt;3), $start32.code32 # Tell assembler to generate 32-bit code now.start32: # Set up the protected-mode data segment registers movw $(SEG_KDATA&lt;&lt;3), %ax # Our data segment selector movw %ax, %ds # -&gt; DS: Data Segment movw %ax, %es # -&gt; ES: Extra Segment movw %ax, %ss # -&gt; SS: Stack Segment movw $0, %ax # Zero segments not ready for use movw %ax, %fs # -&gt; FS movw %ax, %gs # -&gt; GS # Set up the stack pointer and call into C. # we set esp as $start so code and stack won&apos;t interact with each other movl $start, %esp call bootmain After set several registers, we set %esp points to the address of $start, as I comment at the end of start:, we will see that at the end. Because we need to have our stack, then there is some spare space before start code, we use them as stack. Also, code goes up and stack goes down. They will never interact with each other, which is good. Alright, now let’s follow the code to see bootmain.c: 1234567891011121314151617181920212223242526272829303132voidbootmain(void)&#123; struct elfhdr *elf; struct proghdr *ph, *eph; void (*entry)(void); uchar* pa; elf = (struct elfhdr*)0x10000; // scratch space // Read 1st page off disk readseg((uchar*)elf, 4096, 0); // Is this an ELF executable? if(elf-&gt;magic != ELF_MAGIC) return; // let bootasm.S handle error // Load each program segment (ignores ph flags). ph = (struct proghdr*)((uchar*)elf + elf-&gt;phoff); eph = ph + elf-&gt;phnum; for(; ph &lt; eph; ph++)&#123; pa = (uchar*)ph-&gt;paddr; readseg(pa, ph-&gt;filesz, ph-&gt;off); if(ph-&gt;memsz &gt; ph-&gt;filesz) stosb(pa + ph-&gt;filesz, 0, ph-&gt;memsz - ph-&gt;filesz); &#125; // Call the entry point from the ELF header. // Does not return! (see entry.S file) entry = (void(*)(void))(elf-&gt;entry); entry();&#125; It is so hard to understand what the code does, but we know it load elf file header(which is located at 0x10000 ) to help them to load real kernel to the RAM. Let’s go to entry. 123456789101112131415161718192021222324entry: # Turn on page size extension for 4Mbyte pages movl %cr4, %eax orl $(CR4_PSE), %eax movl %eax, %cr4 # Set page directory movl $(V2P_WO(entrypgdir)), %eax movl %eax, %cr3 # Turn on paging. movl %cr0, %eax orl $(CR0_PG|CR0_WP), %eax movl %eax, %cr0 # Set up the stack pointer. movl $(stack + KSTACKSIZE), %esp # Jump to main(), and switch to executing at # high addresses. The indirect call is needed because # the assembler produces a PC-relative instruction # for a direct jump. mov $main, %eax jmp *%eax.comm stack, KSTACKSIZE Oh, it sets the control registers again. then go to main()! Yeah, finally we see something familiar. Let’s take a look. 123456789101112131415161718192021222324252627// Bootstrap processor starts running C code here.// Allocate a real stack and switch to it, first// doing some setup required for memory allocator to work.intmain(void)&#123; kinit1(end, P2V(4*1024*1024)); // phys page allocator kvmalloc(); // kernel page table mpinit(); // detect other processors lapicinit(); // interrupt controller seginit(); // segment descriptors picinit(); // disable pic ioapicinit(); // another interrupt controller consoleinit(); // console hardware uartinit(); // serial port pinit(); // process table tvinit(); // trap vectors binit(); // buffer cache fileinit(); // file table ideinit(); // disk startothers(); // start other processors kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers() / userinit(); // first user process &lt;======== This is our FOCUS \ mpmain(); // finish this processor's setup&#125; The first process - initcode.S Reference [1]. http://linbo.github.io/2018/04/14/xv6-first_process_1. [2]. http://ybin.cc/os/xv6-init-process/.]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EECS_343_Operating_System]]></title>
    <url>%2F2019%2F04%2F16%2FEECS-343-Operating-System%2F</url>
    <content type="text"><![CDATA[This is the first course note because OS is too important. I don’t want to return my knowledge to my professor, I need to keep the knowledge around me. lol. This course is offered by Prof. Stephen Tarzia. [TOC] 1. Introduction blah blah blah. 2. Processes &amp; System calls Process is the execution unit of a CPU. Limited direct execution is a strategy to let many processes to share a single CPU as if they are all has full use of the CPU and memory(In the view of user, because you cannot tell the difference between 100ms and 100ns, lol) OS will divide execution part into user mode part and kernel mode part. It will prevent user processes from doing harmful operations. If user want to do something, it needs to use system call. System calls are software interrupts(Yes, we have hardware interrupts also, like I/O interrupts, NIC interrupts and etc.) Because Interrupts is the only reason to cause the kernel to run, so we need set a Timer Interrupt to ensure that the kernel will run eventually. 3. Process creation and memory layout we use fork+exec to create a process and load a program code so that a program can be run in a process. Nondeterminism means that a programs’ output is unpredictable. To easily switch from one process to another, we need to store some registers value in user’s address space. 4. Scheduling So if we have multiple processes, we need to set up a policy to share the CPU(If we only have one CPU, sad…). Two metrics: turnaround time &amp; response time. turnaround time: Tturnaround=Tfinish−TarrivalT_{turnaround} = T_{finish} - T_{arrival}Tturnaround​=Tfinish​−Tarrival​. Optimized by Shortest Time-toComplete First (STCF). response time: Tresponse=Tstart−TarrivalT_{response} = T_{start} - T_{arrival}Tresponse​=Tstart​−Tarrival​. Optimized by Round Robin (RR). Context switch overhead is because of CPU cache missing. Multi-Level Feedback Queue. A process goes to the highest priority queue when coming in. A processes with higher priority executes first. Same priority processes executes in RR. (context switch overhead). A process can use limited time of one priority queue, if use up, it should be moved to the next lower priority queue. All processes will to go highest priority queue in a fixed period of time. 4.1 Mechanism and policy[Still not clear] The policies what is to be done while the mechanism specifies how it is to be done. For instance, the timer construct for ensuring CPU protection is mechanism. On the other hand, the decision of how long the timer is set for a particular user is a policy decision. The policy indicates what we need to do and the mechanism tells us how exactly we will implement this policy. Like we have several scheduling policies like FIFO, SJF, STCF, RR and MLFQ. But how to implement this, we have different ways. 5. Virtual Memory &amp; Paging[🌟] Even given a virtual memory address, the addresses store in CR3, page directory table and page tables are still PHYSICAL address! Because alignment, the addresses stored in page directory table only use higher bits to store the part of real physical address(because lower part bits are zero, no need to store them), the lower bits are used as flags to indicate if the entry can be used or not. Here is an classic one-level and two-level paging example.(from Prof. Stephen Tarzia slides.) 6. Memory management optimization Even we use virtual memory to solve some problem in view of user. But for OS, we have another problem to consider. Latency cost, because now we have to translate virtual memory to physical memory which takes a lot of time! We introduce Translation Lookaside Buffer(TLB) caches most recent physical page translations. Space cost, because we create page directory table and page table to store real page table entry or page entry, which costs memory space. For different demands we use different level paging, and even combine them. Another ways to reduce memory demands like copy-on-write fork(Project 2), demand zeroing, lazy loading and library sharing and etc. 7. Swapping If we cannot keep latency low, let’s increase the throughput! Disk is slow but large, and can be used to store RAM’s overflow Paging and swapping work together, using the same CPU mechanisms. Paging replacement policy decides which page to be evicted. Thrashing is a state, in which system cannot doing anything because of swapping. Unified page cache handles both traditional paging and file caching to make user fell file system access is just as fast as memory access. 8. Free-space Managements Free space memory is put on a free list. Free space management policy determines: Which free blocks to choose for an allocation When to coalesce adjacent free blocks. Four policies: First fit, next fit, best fit and worst fit. x. Project 0. Basic knowledge for Projects xv6-the-first-process 1. Issues: 1.1 Download the source code 1$ git clone https://USERNAME@github.com/starzia-teaching/project-1-GROUPNAME.git Notice that I added my github username to the user above, before &quot;@github.com&quot;. If you get an error related to gnome-ssh-askpass then try running unsetenv SSH_ASKPASS first (or log in with X11 forwarding). Be careful that on Internet we will see unset SSH_ASKPASS which may not works. But unsetenv works for me. *Update: unsetenv SSH_ASKPASS works for tcsh shell and unset SSH_ASKPASS works for bash and zsh shell.]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
      <tags>
        <tag>Course notes</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EECS_377_GameStudio]]></title>
    <url>%2F2019%2F03%2F15%2FEECS-377-GameStudio%2F</url>
    <content type="text"><![CDATA[This is a really fun course to have. I’ve made a tiny game with my teammate using Unity. If you wanna play it you can download the game from here. We provide both Mac and PC version. Sorry about no Linux lol. Hanzhi]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
      <tags>
        <tag>final summary</tag>
        <tag>Game</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EECS_368_CUDA]]></title>
    <url>%2F2019%2F03%2F15%2FEECS-368-CUDA%2F</url>
    <content type="text"><![CDATA[This course is talking about parallel computing using CUDA. We cover basic concepts like threads, blocks and grids. We have 4 labs in the class. Attention: This is just a brief summary, so it may be not clear to understand. [TOC] 1 Basic Idea A thread is the unit to process code. A block is a bunch of threads. A grid is a bunch of block. In CUDA, grid and block can be multi-dimension. In memory access, one thread can have their own memory(in face assigned global memory), block have their own shared memory which can be accessed by all threads in the same block. Then comes to global memory, everyone in CUDA can access it, but it cost like 400 cycle time. 2 Things to be considered 2.1 coalesce For paralleling programming, one thing we need to pay attention to is how to retrieve data without 1)efficiently and 2)conflict. This part I want to talk about efficiency. When we talk about retrieving data, we know that every thread will try to access the memory. However, it is only possible for one thread to access the memory if using the naive memory access. We want to retrieve data as much as possible. Is there one way that we can retrieve all the data out from the memory with single memory read? The answer is yes, we can coalesce data needed by those threads in a continuous memory space. Suppose every thread needs 1 int data which cost 4 bytes in c++. In one warp, we can retrieve 4×32=128bytes4 \times 32 = 128bytes4×32=128bytes from the memory, and assign different value to different thread. This is why we most use CUDA to process array data not something like objects. 2.2 bank conflict In CUDA, the SM(stream process) will load a warp of threads to execute the code. The size of one warp is usually 32. As we have talked in the previous part, one time memory access may retrieve 32*data_size data. How we load this data, we load them from bank. Bank is not a data structure, but a way or a clarification how we load data from shared memory. Bank can have different width, we don’t care about this now. Remember, bank is only discussed in a SINGLE warp, also, only in shared memory. Because every thread in a warp wants to read data, they will load data just from different bank. If we have 32 threads in a warp, we will have 32 banks to be mapped. How bank classify data? For a continuous bytes of data, say 64bytes. Suppose warp size is 32. Now bytes 1, 2, 3,…, 32 will be classified in bank 0, 1, 2,…, 31, and bytes 33, 34, 35,…,64 will be classified in bank 0, 1, 2,…,31. Why we say classified not assigned, it is because even though bytes 0 and bytes 33 is classified in the same bank, but they still stored in the shared memory, when thread asks for bytes 0, the data of bytes 0 will be loaded into bank 0 and used by the thread. So in this case, if there is another thread asks for bytes 33, then bytes 33 also needs to be loaded to bank 0. Then comes to a bank conflict. Bank conflict usually because of even times stride like 2, 4, and so on. Sometimes we can avoid this but sometimes we cannot, so we will add padding to move the real data backward to avoid bank conflict. Like previous scenario, if we add one more padding after every 32 bytes data, the bytes “33” now is bytes 34 and will be loaded in bank 1, not bank 0. 2.3 Tiling Even we can load very large data into CUDA device, the memory of CUDA is limited. So if the source data size is too large we have to tile the original data into small pieces, and load them one by one to CUDA device, and integrate them at last. Besides, those need repeating operation data also need to be tiled into shared memory to be speeded up. 3 Lab in this course 3.1 Matrix Multiplication 3.2 Tiled Matrix Multiplication 3.3 Optimizing Histograms 3.4 Parallel Prefix Scans This is the most interesting lab, I haven’t realized we can use recursive calling in CUDA, though I should have realized this….]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
      <tags>
        <tag>final summary</tag>
        <tag>CUDA</tag>
        <tag>Parallel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EECS_340_ComputerNetwork]]></title>
    <url>%2F2019%2F03%2F15%2FEECS-340-ComputerNetwork%2F</url>
    <content type="text"><![CDATA[Computer Network(Top-to-down) this is a brief summary of my 2019spring course, computer network. During this course, we talk about 4 main layers in current network architecture. They are Application layer, Transport layer, Network layer and Data Link layer. We also have 3 projects for Application layer. Transport layer, and network layer. This course is offered by Prof. Yan Chen [TOC] 0 Instruction The most important thing in this class is to understand what we really want to do and how we do it. Currently, we all can connect to the Internet, we can use browser to see many different webpages, we can use laptop to play games, we can ssh, we can download, we can do almost anything we want. But how we do this? Let’s say all these things are called application data, which is really familiar to CS student or related-to-CS majors students. We cannot just pass this original application data to others, right? Why? Because we don’t know what to do, you just give me the data, where should I go? Like you want to deliver a package but you NEED address to locate the destination! That’s why we ENCAPSULATE the original data into a packet(usually TCP or UDP), which will indicates some information about this application data and how to deal with it. But in reality, we all know that in order to deliver a package, the address is not the only thing necessary, we also need ZIP, need car or trunk, and even receivers’ phone number. This all of them will help us to deliver a package correctly. Yes, transport layer, network layer and data link layer are doing the stuff. More accurately, we can say transport layer just a car, network layer and data link layer indicate the address of a packet. We will encapsulate them one by one, and break them down one by one. Here is a brief illustration of this process. 1 Application Layer The communication between different application is in fact process communicating. Usually we use sockets. 1.1 Web and HTTP 1.2 Electronic Mail 1.3 DNS 2 Transport Layer 2.1 UDP 2.1.1 checksum 2.2 reliable transfer protocol 2.2.1 rdt1.0 &amp; rdt 2.0 2.2.2 rdt2.1 &amp; rdt 2.2 2.2.3 rdt3.0 (stop-and-wait) 2.2.4 Go-Back-N &amp; selective repeat 2.3 TCP 2.3.1 seq # &amp; acks 2.3.2 Fast Retransmit 2.3.3 Flow Control &amp; Congestion Control 3 Network Layer 3.1 Forwarding Table 3.2 IP datagram format 3.3 NAT It will alter the source IP to routers IP and other port #, so it also have a mapping table between port # of router and the host. 3.4 Routering Algorithms Link-state(LS): Dijkstra Distance Vector(DV): Bellman-Ford 3.5 Hierarchy Routing We can’t store all dest’s in routing tables. Routing table exchange would swamp links! So we aggregate routers into regions, called “Autonomous systems”(AS). When we have hierarchy, we need to consider the routing between AS and inside AS, also called inter-AS and intra-AS. Intra-AS usually uses OSPF and RIP to router. The former is used in upper-tier ISPs and RIP is used in ISPs and enterprise networks.[Note: OSPF uses LS while RIP uses DV] Inter-AS usually uses BGP, and BGP is split into iBGP(internal BGP) and eBGP(external BGP). BGP uses DV. Routing policy: We classify 4 types router information, provider, customer, peer and ISP. For an AS, it will receive and store all incoming router information but for different people, they provide different message. Here is the illustration. (From Prof. Yan Chen slides) 4 Data Link Layer 4.1 MAC address Because IP is fixed in a given area like ZIP code, so how we identify a unique user under the same IP? This is why we need another address to locate a user and this address is called MAC address. MAC address is 48bits in such format:xx-xx-xx-xx-xx-xx. 4.2 Error detection and correction We use CRC error detection in this layer and add CRC at the end of frame. Also, we talk about parity bit and 2-dimension parity bit. 4.3 Hub and Switch Hub is a dumb device, just knows repeating one’s information to other(broadcast). But switch is smarter than hub, it will selectively to forward frame to different interface. This help switch to isolate collision domains. In reality, it seems another way to isolation collision domain called VLAN. But it is not the scope of this class. In reality, many devices share the media, that causes collision among them. So we can use Channel Partition(TDMA or FDMA) or Random Access(Aloha or CSMA) to solve this problem. 4.4 ARP We use this to get the MAC address of other host. It is very important that the source and destination MAC in ARP is different with those in the head of Ethernet head, which is used to addressing. Here is an ARP message format(from http://www.cs.virginia.edu/~cs458/slides/module06-arpV2.pdf) The one thing I don’t understand is that ARP is used to obtain MAC, and MAC is only used to addressing under the same subnet. WHY do we consider a scenario that one host A want to get another host B’s MAC address in a different subnet? Host A won’t send ARP to host B because they are not in the same subnet, host A will just send ARP to request gateway’s MAC address.]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
      <tags>
        <tag>Computer network</tag>
        <tag>final summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka]]></title>
    <url>%2F2019%2F02%2F08%2FKafka%2F</url>
    <content type="text"><![CDATA[It is my first step to study intern-related doc by myself. I haven’t realized the power of self-learning until I come to the U.S for graduate study. I hope I can keep this power forever and do something more meaningful.]]></content>
      <tags>
        <tag>Intern</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EECS475_MachineLearning]]></title>
    <url>%2F2018%2F12%2F17%2FEECS475-MachineLearning%2F</url>
    <content type="text"><![CDATA[Machine Learning Introduction It is really strange about ML. Because at first I thought it is something difficult, and the work in the real world is the same. But after talking with some classmates, I find that most of them just use the model, and don’t know the truth of it, which goes against my idea of study. All the time I think, no matter what, I need to absorb the truth of one thing to convince myself that I am really understand it. But my classmate gives me a feeling that this field has a low threshold and this feeling makes me uncomfortable. I know ML is the frontier of computer science but it hurts me when I find this phnomenon. I am really interested in ML. I hope I can be another kinds of people who really understand the concept of ML. I know I am just talking, but I hope I can do what I said. Linear regression logicla regression classification 2 classification n classification non-linear regression]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
      <tags>
        <tag>final summary</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EECS495_Intro_to_database]]></title>
    <url>%2F2018%2F12%2F17%2FEECS495-Intro-to-database%2F</url>
    <content type="text"><![CDATA[Intro to Database this is a brief summary of this course, since quarter is at the end, no excuse not to write a summary 😃 I will summary every chapter of this course and then make a whole summary. [TOC] DB fundamentals Database like txt file or another file storage type. It stores data, but why we design a new model to store the data not just use what we have now? Because of efficiency, database can retrieve data more quick than normal type file storage. Moreover, it can normalize the data to make them more conpact to reduce space usage which is also important for large scale system. Database is a large collection of organized data. Database Management System(DBMS) is a tool designed to manage and utilize databases. In database, there is one important concept: Table, it contains several components: Schema: Descripor of the records stored in a table. Attribute: A column of a table Tuple: A record/row in a table Field: A cell in a tuple Here is a illustration picture: Query Language is a specialized laguage for retrieving and manipulating data used with a DBMS, but a Query is just a command written in Query Language to DBMS. Here is an example query language(MySQL): 1234SELECT department, COUNT(*)FROM employees eWHERE e.age &gt; 18GROUP BY department ERD A direct diagram to illustrate the relationship between different entities, but what is entity? Entity is a box, containg all the information in a table. You can see it as a pictural discriptor of table. It contains attributes, and relationships with other entities. Entity: a rectangle Attribute: an oval (Primary Key should be highlighted with a underline) Relationship: a line with some notation (To indicate 1-1, 1-M, M-M relationship) (It can contains Attrs too) Generalization Hierarchy: Disjoint: can be only one of them Overlapping: can be any of them. isa hierarchy: will be introduce in the future Weak Entity: Occurs in 1-M relationships, for example, in 2 different teams, both has a teammate called No.2, then we have to combine team name and their number to locate the person accurately.[This entity will be represented by a double rectangle] Here is a example, including both normal ERD and weak entity: Relational Model When we get ERD, how we change it into a relational model, which is also known as schema? Here are some solutions for different kinds of problems. 1-M Add the key of “1” entity, as a foreign key to the table of “M” entity Add the attributes of the relationship type M-M We add the key of both entities to relationship model. 1-1 This is a special case for 1-M, so it is the same. Weak Entity This is also a special case for 1-M, so we add primary key of Strong entity as a foreign key to the weak entity. Subclass Objected-oriented: create a model for each entity, but subclasses will contains every attributes of parent’s entity. This is useful for queries involving both common and special attributes. Use nulls: create only one parent entity and add all subclass’s attributes to parent’s model. This is useful for queries like special member number almost equals to number of members in superclass. ER style: Create a model for each entity, and subclass only contains parent’s primary key(s) This is useful for queries involving the the common attributes of the superclass. Relational Algebra When we have Relational Model, how we retrieve the data we want? Sometimes we can get the data just from one model, but most of the time we have to retrieve data from the combination of different models(schemas). Relational Algebra is used to do this stuff. It helps us to be more clear about the procedure to retrieve the required data. Union R1⋃R2R1 \bigcup R2R1⋃R2 Intersection R1⋂R2R1 \bigcap R2R1⋂R2 Difference R1−R2R1 - R2R1−R2 Projection πA1,A2,...(R)\pi_{A1,A2, ...}(R)πA1,A2,...​(R), we project corresponding columns out of relation R Selection σlength≥100(Movies)\sigma_{length \geq 100}(Movies)σlength≥100​(Movies), we select rows in Movies those length is greater or equals to 100. Cartesian(Cross) Product R1×R2R1 \times R2R1×R2 Theta(Conditional) Join R1⋈CR2R1 \bowtie_{C} R2R1⋈C​R2 Natural join connect 2 relations by common attributes and same field. Rename R1=ρR1(A1,...,An)(R2)R1 = \rho_{R1(A1, ..., An)}(R2)R1=ρR1(A1,...,An)​(R2) Division R=R1/R2R = R1 / R2R=R1/R2 We commonly use expression tree or relational algebra to express the data we want to retrieve. Here is 2 examples respectively. QUERY : The names of all the bars that are either on Maple St. or sell Bud for less than $3. QUERY : patient IDs that have seen a pediatrician we have scheme as follows: hospital(hosp_id, h_name, h_addr) doctor(doctor_id, d_name, d_specialty, hosp_id) patient(patient_id, p_name, p_dob, doctor_id) πpatient(patients⋈doctor_idσspecialty=′pediatrician′(doctors))\pi_{patient}(patients \bowtie_{doctor\_id}\sigma_{specialty=&#x27;pediatrician&#x27;}(doctors))πpatient​(patients⋈doctor_id​σspecialty=′pediatrician′​(doctors)) SQL Part I Now we know about the relationships between entities and how to retrieve the data in logical way. Now we need to create real entity which now is called Table. Here is an example of creating a table in sql: 12345678CREATE TABLE movie ( movie_id NUMBER PRIMARY KEY, name CHAR(20) NOT NULL, city VARCHAR(20) NOT NULL, state CHAR(2) NOT NULL, release_date DATE, CONSTRAINT release_date_contraint CHECK (release_date between '01-Jan-1980' and '31-Dec-1989')) In the above code, we notice that there are some UPPERCASE WORDS like PRIMARY KEY, NOT NULL, CONSTRAINT. Those are called Integrity Constraints(IC). NUMBER, CHAR, VARCHAR and DATE are Date Type SQL Part II Advanced SQL Programming in SQL PL/SQL and Functional Dependency Normalization Transaction Deadlock &amp; Isolation Level Disk Storage &amp; Management Indexing Hashed Indexing &amp; Query Cost Join &amp; Multidim Modeling MDX Queries Graph Database]]></content>
      <categories>
        <category>Northwestern University</category>
      </categories>
      <tags>
        <tag>final summary</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Summary ByTag]]></title>
    <url>%2F2018%2F09%2F19%2FLeetCode-Summary-ByTag%2F</url>
    <content type="text"><![CDATA[LeetCode Summary By Tag To make it easier to review the leetcode, classify different into groups according to its tags. LeetCode Summary By Tag 1. Array 1. Two Sum 11. Container With Most Water 15. 3Sum 16. 3Sum Closest 18. 4Sum 26. Remove Duplicates from Sorted Array 27. Remove Element 41. First Missing Positive 42. Trapping Rain Water 2. Number 3. List 1. Array 1. Two Sum Discription: Click Here Idea: a. loop through + binary search; O(N)*O(logN) = O(NlogN) time performance, O(1) space cose; b. HashMap to record the whole array then loop through the array. O(N) time performance and O(N) space cose; 11. Container With Most Water Discription: Click Here Idea: two pointers, move the lower one to the higher one, update localMax and globalMax. 15. 3Sum Discription: Clikc Here Idea: 3 pointers, a, b, and c. FIRST, sort the array. a is used to loop throught the first num, b and c are used to scan the remaining array element from two sides. which leads to O(N) time. With O(N) time to LOOP throught the whole array, we use up to O(N2)O(N^2)O(N2) time. 16. 3Sum Closest Discription: Click Here Idea: Same idea with #15 18. 4Sum Discription: Click Here Idea: Same idea with #15, but need 4 pointers and cost O(N3)O(N^3)O(N3) time. 26. Remove Duplicates from Sorted Array Discription: Click Here Idea: In-place, so we can record how many repeated numbers in this array and move the first of duplicates or non-duplicate forward. 27. Remove Element Discription: Click Here Idea: Same with #26 41. First Missing Positive Discription: Click Here Idea: Build an array to record the presence of positive integer. Loop the whole array to update this array. Then loop this array from start and we will find the first missing positive number. This costs O(N) time. 42. Trapping Rain Water Discription: Click Here Idea: Builde 2 pointers, left and right. move the lower one to higher one; we need to update trapped water in a way that lower one stop once encounter a higher one. Say that left one is lower one, we move a temp pointer to right and every movement we see if current value(where pointer points) is lower than the value left pointer points. If it is then update left pointer to temp pointer. If not, return to 2. 2. Number 3. List]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode New Summary]]></title>
    <url>%2F2018%2F06%2F18%2FLeetCode-New-Summary%2F</url>
    <content type="text"><![CDATA[LeetCode New Summary This is a review of every lc problems I have done. 0 - 100 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. IDEA: a. sorted -&gt; binary search -&gt; O(N) to search first num and O(logN) which leads to O(NlogN) in total and O(1) space cost. b. use HashMap, O(N) time cost and O(N) space cose. 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. IDEA: a. one temp var to record carry bit. 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb” Output: 3 Explanation: The answer is “abc”, with the length of 3. Example 2: Input: “bbbbb” Output: 1 Explanation: The answer is “b”, with the length of 1. Example 3: Input: “pwwkew” Output: 3 Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. IDEA: record every char’s index, once repeat, update globalMaxLength and localMaxLength; 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 IDEA: need to be write in detail The median of an array is a number that divide the array into 2 subarray, every num in the left array is smaller than the median and every num in the right array is larger than the median. 91. Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: ‘A’ -&gt; 1 ‘B’ -&gt; 2 … ‘Z’ -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: “12” Output: 2 Explanation: It could be decoded as “AB” (1 2) or “L” (12). Example 2: Input: “226” Output: 3 Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6). IDEA: DP solution: Apparently, for every digit we need to see if it is valid([1 ~ 9]), then the digit comes after need to do the check too([10 ~ 26]), so we have 2 choices for every digit except for some corner cases. Let’s consider buttom-up solution, which is from right to left in this problem. For i-th digit, if it is valid, then #the i-th total decode ways += total (i+1)-th decode ways. If (i_i+1) two digits are valid, then #the i-th total decode ways += (i+2)-th decode ways. This is showed as follows: DP[i] = DP[i + 1] + DP[i + 2] 100 - 200 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. IDEA: dfs, recursive solution 136. Single Number [E] Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 IDEA: linear time -&gt; two loop, one loop to calculate the freq and one loop to find the single number. If require no extra memory, we can use ^ oprator, because a ^ a ^ b = b. 200 - 300 274. H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” Example: Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3. IDEA: Solution 1: sort the array, back to front. Time Performance: O(nlogn) Space Performance: O(1) Solution 2: The key of this problem is that the range of h is [0, N], so we can use bucket index to present potential h-idx and the value in bucket to denote the number of papers cited more than bucket index. So one loop for original array to update bucket array and one loop for bucket array to find h-idx. Time Performance: O(N) Space Performance: O(N) 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. IDEA: it is important to find that it is relative to those multiples of 4. 300 - 400 337. House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. IDEA: naive recursive solution -&gt; pruning solution(using HashMap) -&gt; DP solution(return results under 2 different conditions) 344. Reverse String [E] Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. IDEA: easy swap 400 - 500 461. Hamming Distance [Easy] The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. IDEA: Integer.bitCount() 463. Island Perimeter You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. IDEA: THIS IS ONLY ONE ISLAND. So go throught the whole 2D-array, for every ‘1’, we check its surrounding value and calculate its perimeter, and update the how perimeter. 500 - 600 513. Find Bottom Left Tree Value [Medium] Given a binary tree, find the leftmost value in the last row of the tree. IDEA: Easy BFS and push node in left to right order. Then store the val from the first out node. 561. Array Partition I Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. IDEA: greedy: sort then sum one out of every 2 numbers. 600 - 700 605. Can Place Flowers Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False Note: The input array won’t violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won’t exceed the input array size. IDEA: TWO corner cases: the first and the end of the array. 637. Average of Levels in Binary Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. IDEA: BFS and calculate average, be careful about the result date type, int is not eligible 646. Maximum Length of Pair Chain Idea: The tag of this problem is DP but it seems like a greedy problem and I cannot figure out how to use dp to solve it? 657. Judge Route Circle [Easy] Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. IDEA: Easy, no 693. Binary Number with Alternating Bits Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101 Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111. Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011. Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010. IDEA: O(32) solution, check every bit n -&gt; 32-bit ‘1’ -&gt; n&amp;(n + 1) == 0 ? 698. Partition to K Equal Sum Subsets Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Note: 1 &lt;= k &lt;= len(nums) &lt;= 16. 0 &lt; nums[i] &lt; 10000. IDEA: ONE OF THE MOST DISGUSTING PROBLEM: Hints : buckets. 700 - 800 766. Toeplitz Matrix A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. IDEA: brute force. We have to check every elements. 800 - 900 811. Subdomain Visit Count [Easy] A website domain like “discuss.leetcode.com” consists of various subdomains. At the top level, we have “com”, at the next level, we have “leetcode.com”, and at the lowest level, “discuss.leetcode.com”. When we visit a domain like “discuss.leetcode.com”, we will also visit the parent domains “leetcode.com” and “com” implicitly. Now, call a “count-paired domain” to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be “9001 discuss.leetcode.com”. We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input: [“9001 discuss.leetcode.com”] Output: [“9001 discuss.leetcode.com”, “9001 leetcode.com”, “9001 com”] Explanation: We only have one website domain: “discuss.leetcode.com”. As discussed above, the subdomain “leetcode.com” and “com” will also be visited. So they will all be visited 9001 times. Example 2: Input: [“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”] Output: [“901 mail.com”,“50 yahoo.com”,“900 google.mail.com”,“5 wiki.org”,“5 org”,“1 intel.mail.com”,“951 com”] Explanation: We will visit “google.mail.com” 900 times, “yahoo.com” 50 times, “intel.mail.com” once and “wiki.org” 5 times. For the subdomains, we IDEA: Easy HashMap 852. Peak Index in a Mountain Array Let’s call an array A a mountain if the following properties hold: A.length &gt;= 3 There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1 Example 2: Input: [0,2,1,0] Output: 1 Note: 3 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^6 A is a mountain, as defined above. IDEA: Because it is definitely a mountain, we can binary search the topest value in this array and return its index. 853. Car Fleet N cars are going to the same destination along a one lane road. The destination is target miles away. Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road. A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.The distance between these two cars is ignored - they are assumed to have the same position. A car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet. If a car catches up to a car fleet right at the destination point,it will still be considered as one car fleet. How many car fleets will arrive at the destination? Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 and 8 become a fleet, meeting each other at 12. The car starting at 0 doesn’t catch up to any other car, so it is a fleet by itself. The cars starting at 5 and 3 become a fleet, meeting each other at 6. Note that no other cars meet these fleets before the destination, so the answer is 3. Note: 0 &lt;= N &lt;= 10 ^ 4 0 &lt; target &lt;= 10 ^ 6 0 &lt; speed[i] &lt;= 10 ^ 6 0 &lt;= position[i] &lt; target All initial positions are different. IDEA: We need to find the fleets, so we need to know if one car will catch another one. To simplify the process, we sort the original position array, let’s say in ascending sequence, then we have a new array, let’s name it pos. Then the end of pos is closest to the target and the head of pos is farest to the target. Now from the end of the array, we calculate the time that every car need to take to reach the target, if one car A firstly is ahead of car B but the time of car A need to take to reach the target is larger than B’s time, it means that car B catches car A in no doubt, which means they are views as one car fleet. So the key of this solution is: sort position calculate the time consumption compare the time consumption from the end to the head with current time and determine the occurence of car catching. CODE 854. K-Similar Strings Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B. Given two anagrams A and B, return the smallest K for which A and B are K-similar. Example 1: Input: A = “ab”, B = “ba” Output: 1 Example 2: Input: A = “abc”, B = “bca” Output: 2 Example 3: Input: A = “abac”, B = “baca” Output: 2 Example 4: Input: A = “aabc”, B = “abca” Output: 2 Note: &lt;= A.length == B.length &lt;= 20 A and B contain only lowercase letters from the set {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’} IDEA: When it comes to the shortest distance or shortest of something, we need to consider BFS first. After all, it is the most common algs to solve this problem. In this problem, we use BFS to guarantee the result is shortest, then we swap every pair in A to reach B and offer (because in java queue, the func is offer()) all the results to queue then use BFS to solve it. CODE 855. Exam Room In an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room. It is guaranteed that any calls to ExamRoom.leave§ have a student sitting in seat p. Example 1: Input: [“ExamRoom”,“seat”,“seat”,“seat”,“seat”,“leave”,“seat”], [[10],[],[],[],[],[4],[]] Output: [null,0,9,4,2,null,5] Explanation: ExamRoom(10) -&gt; null seat() -&gt; 0, no one is in the room, then the student sits at seat number 0. seat() -&gt; 9, the student sits at the last seat number 9. seat() -&gt; 4, the student sits at the last seat number 4. seat() -&gt; 2, the student sits at the last seat number 2. leave(4) -&gt; null seat() -&gt; 5, the student​​​​​​​ sits at the last seat number 5. ​​ Note: 0 &lt;= N &lt;= 10^9 ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. Calls to ExamRoom.leave§ are guaranteed to have a student currently sitting in seat number p. IDEA: We notice that the range of N is from 0 to 10^9 so it is not wise to create an array to store every seat’s state. We can use segment to present the seat’s state and two points of a segment are both occupied. In this case, the corner case are the first seat and the last point because their segments have just one point and the other is the boundry of the array which we need pay attention to. Solution: Keyword: TreeSet, Point, Priority(Haven’t been reached, do it in few days later) CODE]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms]]></title>
    <url>%2F2018%2F05%2F09%2FAlgorithms%2F</url>
    <content type="text"><![CDATA[ALGORITHM This is how I learn algorithm. 1. Backtracking 2. DP ( learning ) The following link is very helpful to understand the kernel of DP and what’s dp and how to use it. MIT Dynamic Programming Normally, when it comes to brute force, it involves exponential time performance. Take subsets as an example, for every single elements, we have to decide use it or not, so for the length n, we have 2 to n possibilites which is exponential. BUT, in some problems, we can divide them into subproblems, and subproblems will always show up with recursion, in this way, we can make code clearlier and conciser. However, subproblems can be repeating, in topological way, it is said that the topological structrue is the same. So if we take no steps to avoid this or optimize the performance, the time performance is still bad. Then that is the key of Dynamic Programming, we store every subproblem’s result in memory, every time we encounter a repeating subproblem, we just use the result and apparently we reduce the time consumption down to O(1) In the former link, the lecturer has listed 5 steps to use dp to solve problems: find/define subproblems guessing, how many choices I have ( #choices ) relate subproblems ( time/subproblem) recurse and memorized / build up DP table ( total time ) solve original problem. 3. BFS &amp; DFS 4. Patient Sorting ( used for LIS, Longest Increasing Sequence ) Given an array, loop through the whole array and build piles based on two rules: The bigger num cannot place on a lowwer num, if none of current piles can be placed on, then create a new pile; keep number of piles as small as possible. To get a LIS given an array, when we have former rules, we can follow these steps: 123456while ( ) &#123; 1. build pile and pointer that points to the current top element of the pile 2. whenever place a new element to a pile, update its top element and its pointer to previous pile's top elements. 3. from the rightmost element, then go back to the first pile based on the pointer value, and we will get the target LIS.&#125; 5. Quick sort &amp; Quick select time analysis We both know these 2 algorithms but for time complexity I am confused about why one is O(nlogn) and the other is O(n). After doing the time complexity by myself one time I finally figure it out: For Quick sort, we have T(n)=2T(n/2)+O(n)T(n) = 2T(n/2)+O(n) T(n)=2T(n/2)+O(n) While Quick select we only have T(n)=T(n/2)+O(n)T(n) = T(n/2) + O(n) T(n)=T(n/2)+O(n) The parameter before T(n/2) makes a difference!]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Exercise]]></title>
    <url>%2F2018%2F05%2F06%2FLeetCode-Exercise%2F</url>
    <content type="text"><![CDATA[Leetcode > This is a temporary post to record the experience of doing leetcode and will be rewrite and rearrange the layout (Typesetting) ASAP. > In the future I will sum up all the algs I know to a new post and write a new post to record the exercise. Hope I can do it well > 2018.5.6 Updated 2018-5-9, the following days will be tough and I have to rearrange the quantity of leetcode problems. The next 2 weeks’ focus is on GRADUATTION PROJECT &amp; Side Project preparation. Fight. 2018-5-14 98.Validate Binary Search Tree My first thought is using a stack to store the BST in preorder and compare the new-to-stack element’s value a with stack.peek() = b , if a &gt; b then it is false; When I check the Discussion Section and I find a more concise way to solve it. we can use localmin and localmax to restrict the range of local element’s value, but if we want to cover the whole range of Integer we have to set the original value of localmin to Long.MIN_VALUE and localmax to Long.MAX_VALUE which is not recommanded. So we can add two more boolean variable hasMin and hasMax to indicate whether we need check the upperbound or lowerbound. 1boolean isValidBST(TreeNode node, int localMin, int localMax, boolean hasMin, boolean hasMax) 111.Minimum Depth of Binary Tree recursive: compute the minimum depth of every node (left and right), especially when it comes to a situation that left or right is 0, we need to return the other side’s length, and we have a tricky code: 1return (left == 0 || right == 0 ) ? left + right + 1 : Math.min(left, right) + 1; 110.Balanced Binary Tree use the same idea of No.111 problem : compute the length of left and right subtree and compare them and return the boolean value. 257.Binary Tree Paths like a backtracking problem. Have learned the new API of StringBuilder class: 123StringBuilder sb = new StringBuilder();sb.delete(int start, int end); // delete the element from start to end - 1.sb.setLength(int length); // set the length of StringBuilder, I think this one is more convenient than the former one when it comes to deletion. 695.Max Area of Island With a “DFS” tag but it seems like a BFS problem.use a 2d array to record whether a position has been visited. 2018-5-10 343.Integer Break 很难受，没有想出DP的解决方法！！争取明天弄一下DP的方法！ 2018-5-9 今天看到了一个很nice的关于DP的总结，也算是弄清楚了一点点DC,DP和greedy的关系图了。 1、DP算法起源于DC，一个问题的解，可以分解为求解一系列子问题的解。同时包含有重叠子问题。这就得到了DP的第一个黄金准则：某个问题有独立的，重叠的子问题。也就是说，如果子问题不独立，没有办法分治。独立但是不重叠，直接遍历即可，也就是分治的实现。如果有重叠，那就是DP的用武之地了。 2、DP算法的黄金准则2,：最优子问题。很明显，DP的本质在于不重复计算子问题，因为把其计算结果存储起来了。也就是之前说过的state。 Best Time to Buy and Sell Stock with Transaction Fee Best Time to Buy and Sell Stock with Cooldown Best Time to Buy and Sell Stock IV 很难受，有了状态转移方程写不出代码。。 原来之前的代码原理上没有任何问题。。。。出在了边界条件的判断失误，导致少算了一个。 我说思路没问题怎么一直有问题。。 ！！！ Best Time to Buy and Sell Stock III 2018-5-8 Counting Bits 真的很巧妙，右移一位之后，就只要判断奇偶来决定bit的个数了。虽然我和他们遍历一样，但是指令时间花费太多。。。。 而且我只是找到了一个规律，却没有找到更核心简便的规律。更重要的是，没有用DP的思想。。 Best Time to Buy and Sell Stock II Greedy 2018-5-7 Min Cost Climbing Stairs Range Sum Query - Immutable 尽管是在 DP tag下面做的，但是完完全全没有往这个方向去想。。。还是brute force解决。 可以利用sum，记录[0,i] 2018-4-10 Array Partition I Arrays.sort，是Arrays！ Max Consecutive Ones 都说了是Consecutive ones还在考虑连续的0，不知道题目到底看没。 Toeplitz Matrix 关键是对角，不一定要分组的。 Move Zeroes 又是低级错误。。。。数组数值被下标代替。。。。 week 5 1In in = new In(args[0]); &amp;&amp;语句前后顺序很重要！ 12345if( x.lb != null &amp;&amp; rect.intersects(x.lb.rect) ) // the upper and the lower act the sameif( x.lb != null )&#123; if(rect.intersects(x.lb.rect)&#125; 所以一旦反过来变成这样就会出问题，因为x.lb可能为Null 1rect.intersects(x.lb.rect) &amp;&amp; x.lb != null nearest 是x.lb或者x.rt的rect的判断而不是对x.rect的判断 2018-4-11 今天看了两个算法: BFS ： Breadth-First-Search DFS： Deapth-First-Search BFS: 采用FIFO结构 顶点进队列 while（队列非空）{ 把周围的未经过的顶点进队列。 出队列。 } 结束循环，遍历所有节点。 DFS：栈 先把所有节点标白 顶点进栈，将其标灰 while(栈非空）{ if（邻节点有白）{ 节点标灰色 进入节点，将其压栈。 } else （邻节点无白）{ 将该点出栈 } } 2018-4-16 现在准备看KMP算法，在回文算法题的discussion中看到。、 2018-4-17 复习week1 内容，Topological sort是redraw DAG so all edge point upwards.1) DFS, 2) return vertex in postorder 脑子不清醒了： 1、数组元素居然用 [ ] 括起来； 2、数组长度是num.length不是num.length{} 3、二分法的判断条件是high &gt;= low，有一个等于号！！！ ① 167. Two Sum II - Input array is sorted sort 二分法还是不如两头相加来的方便。两头相加真是太牛逼了。 要注意的几个点是 int相加溢出，用long存储。判断参数。 ② 169. Majority Element 自己第一反应是简单粗暴的创建一个65536数组，直接存储，两次for进行brute serach 想想有没有更好的方法 看了discussion： 1、牛逼，充分利用了major element数量大于一半，直接对数计数，遇到就加，碰到就减，最后留下来的肯定是major element 2、bit操作，很神奇。但是不知道为什么能够得到正确的结果。 3、hash table，暂时没学过，明天学习。 4、sorting，直接获取中间位数字即可 ③ 448. Find All Numbers Disappeared in an Array 第一反应： sort之后，根据offset计算disappear的值 看了discussion： 1、利用数组元素作为索引标记。核心在于数组中的元素个数和最大的数是相同的，也就是都是n。我之前以为可以小于n所以一直觉得很有问题。重点还是要好好审题啊。总是有小问题。 得到思路之后自己写，又出现了小问题：写出了List。。。emmm多注意小细节。 提交之后发现有时间更短的，果然用了额外数组空间。 ④ 717. 1-bit and 2-bit Characters 很简答的一道题目。。。emmm就是低级错误还是有: 1、变量都没声明就开始用了。 2、if语句乱用 。。。 3、大思路正确但是细节方面还是有瑕疵，跳跃检查没事但是忽略了最终都会跳到同一个位置。。 ⑤ 121. Best Time to Buy and Sell Stock 思路很清晰的一道题目，但是自己还是考虑不够。 1、先入为主，没有考虑多种可能，认为只有一种可能，所以直接判断左边最小和右边最大。致使[2,4,1]这种testcase都output = 0，（因为左边最小是1所以 1 - 1 = 0） 刚刚看了 Best Time to Buy and Sell Stock II，听说要用贪心算法，没有接触过，明天对其进行了解。 2018-4-18 ① 128. Longest Consecutive Sequence (有问题，没有达到O(n) 的要求却AC 100) 要求O(N)，所以第一反应就是sort之后直接go through，O(n)+O(nlogn),不知道这算不算O(n)…数量级上是一样的。 提交后居然第一次AC 100，卧槽。。。。 尽管如此，第一次提交忽略的一个corner case，就是都是consecutive的时候，就不会执行到else语句当中。这个要多注意。 ★ if-else语句要注意是否都会执行到。 ② 217. Contains Duplicate sort之后直接判断。发现自己已经迷上了sort【然而好像时间复杂度。。。。】 ③ 268. Missing Number sort之后 go through或者二分查找 看了discussion发现，有两个灵性的解法，但是比较特殊，因为只能找到少一个的 1、SUM操作，然后减array 2、XOR操作，因为abb = a，所以将1 ~ n 所有与array中的所有XOR，就能得到missing number ④ 661. Image Smoother 第一反应还是brute 解决。 看完discussion，似乎大多也是brute。 但是有一个厉害的老哥，利用了255是8bit，int是16bit，将前8bit作为计算结果存储，最后整体右移8位！！！强的一笔，节约了一倍的空间。 反思： 1、自己边界判断都能弄错，服了。真是不知道在干嘛。。。。 2、循环变量居然忘记初始化？？？？ ⑤ 628. Maximum Product of Three Numbers 很奇怪，为什么sort之后直接计算的速率还不如不算的速率？因为时间复杂度不同。 ⑥ 746. Min Cost Climbing Stairs go through, i处判断i+1, i+2 第一次提交出错，[0,0,0,0] 很玄学，因为判断顺序的问题，先进行了计算后进行了判断，所以先出界，然后判断。抛出异常 第二次提交出错，[0,2,2,1] 改成两头运算，但是感觉很虚，方法冗长。 思路完全错误，应该动态规划。贪心算法似乎有问题。还是没有搞懂贪心算法和动态规划的区别。这道题目先放一放吧。把这两个算法弄懂了再来做。 ⑦ 697. Degree of an Array 思路: go through array, 统计value（degree），first_index，last_index 然后计算degree，和minimum_length 时间复杂度 go through – O(n) 统计，链表的话就是O(n), hashmap/hashtable 是 O(1) 计算degree， go through O(n) 引出hashmap和hashtable的区别问题。 重新规划，先刷1-300. Two Sum 失去了sorted这个条件就只会brute解决了，看了大神的解答发现可以用HashMap，可以尝试一下用HashMap解决。 Add Two Numbers easy,设置res和carry两个数分别记录加后%10的值和进位，然后判断l1,l2是否为同时为null为结束循环条件。 但是忽略了同时为null时也有可能carry = 1，导致错误。 同时计算res加了c，计算c的时候却没有，同样导致错误。多加小心。 Longest Substring Without Repeating Characters 两个index，一个头一个尾，hashmap存储，一旦tail发现重复，回溯到重复点，重新查找，并且保存当前maxlen 思路正确，但是很遗憾，代码编写错误还是很多。 值得注意的是 1、s.length() 和 a.length String的length是带括号的，而数组不带。 2、找s中对应下标的char是s.charAt(index),而数组直接a[index]即可 3、 |原始类型|封装类| |:—|:----| |boolean| Boolean| |char | Character| |byte | Byte| |short | Short| |int | Integer| |long | Long| |float | Float| |double | Double| 4、遇见if-else一定要多加注意，看有没有可能一直if或者一直else导致某些特定语句没有执行到。。。。 2018-4-20 Reverse Integer 第一反应，boolean sign保留符号，然后abs计算，改成string，逆序，改回long int，输出。 还是太复杂了，直接从尾部go through，但是overflow有一个很奇妙的地方，x / 10 != a即可证明其overflow（https://leetcode.com/problems/reverse-integer/discuss/4060/My-accepted-15-lines-of-code-for-Java/126400?page=1） java int是32bit Palindrome Number 和7一样计算出值直接 ==，而且如果入参 &lt;0 直接返回false Roman to Integer 找最大值，然后go through，小于最大的index做减法，大于的做加法。 仍然有漏洞，最大的可能多次出现。且多次出现仅有可能在头部。 Merge Two Sorted Lists 题目根本没有说要保持sorted。。。 改了之后过了 Valid Parentheses 利用stack，检查。但是时间花费较多，似乎用数组更快，这是为什么呢？ Divide Two Integers (Medium) 这种数据的edge case一定有overflow！！！！ java中 int cannot be converted to boolean 2018-4-21 （29今天也把他弄懂。） Count and Say 递归计算，时间开销很大。 学习其他人的方法。 1、利用循环调用函数进行计算，能用循环尽量用循环，因为递归在不断开销新的资源，每一次调用都会产生新的资源，而循环能够尽量再同一空间上进行计算，能够减少资源的开销。 2、char[] 与 String之间的变化，String有个toCharArray()变成char数组，所以没必要每次都用s.charAt(index)来读取char 3、新学到StringBuilder类 4、数组长度length，字符串长度length() 5、改为循环，仍然没有利用StringBuilder，发现时间开销依旧很大，改为Stringbuilder之后瞬间提升，原因是什么呢？ 这是因为String的长度大小是不可变的，当我们进行拼接的时候重新创建了一个新的String类型数据，所以不断的循环导致不断的开销。而StringBuilder的长度是可变的，所以一直在同一个内存空间操作，速度大大提升。如下图所示 String 长度大小不可变 StringBuffer 和 StringBuilder 长度可变 StringBuffer 线程安全 StringBuilder 线程不安全 StringBuilder 速度快 Search Insert Position easy binary search Remove Duplicates from Sorted Array easy index increase to go through. duplicates is invalid and can be overwrited Remove Element same way as 26 but no need to check index == len - 1. just record the number of deleted elements. Divide Two Integers (Medium) 采用brute方法直接exceed time limit,很难受。看看别人怎么做的吧 1、擦，被秒杀。。。这个bit 操作真的很骚。。。而且我记得之前也有一道题目涉及到了bit操作。 2、其实对divisor进行自加加然后对其结果再次自加，也有移位的效果。 所以其实就是耍了一个trick，说不能用乘除和mod，就利用移位达到快速定位的效果，这个其实也相当于 go through和二分的区别。 Roman to Integer 右有大，负加。 右无大（碰边界），正加。 思路完全正确，之前居然没有想到。 但是发现了新的问题： Java中 Hashmap性能上似乎不如switch语句，原因暂时不知道，只看到了几个关键词：JVM, tableswitch, Lookupswitch, HashMap自己的构造函数中默认构造大小。 Longest Common Prefix 其实是一道没有太大意思的题目，思路清晰，仅仅锻炼一下自己码代码的细节的问题： 1、charAt是函数，用的（）括号而不是 [] 2、char[][] 是不存在的。只有char[] 3、一定要注意自己的for循环里面，是否将 i 写成了常数 2018-4-21 Median of Two Sorted Arrays（） 要求是log(m+n) 重点是弄懂median的作用，其作用是分割成两个部分，左边最大小于右边最小。且左右大小相等。所以基于这个亮点对其中一个进行binarysearch，然后另外一个因为要保持大小相同，所以也在同时binarysearch，达到log的效果。 尽管如此，原理还是没有完全弄透彻。Hard果然是Hard。。。 需要反复复习。 Maximum Subarray 直接遍历整个数组，从第一个大于0开始，sum进行累加， if sum &gt;= 0 i++,maxsum = Math.max( maxsum, sum), else sum &lt; 0, i++, sum = 0; maxsum = Math.max ( maxsum, sum); O(n) 时间复杂度。 说可以用分治的方法 divide and conquer, 开始学习怎么做。 如果按照我刚刚从大于0的开始，要出问题。因为可能全为负值，导致出错。 思路还是正确的，看完讨论发现大家都是O(n)的时间复杂度。 我的思路上是遍历，但是用到了分治的思想，但是自己没有看出来。 分：i 遍历，寻找前 i 个sum最大的。 治：根据第 i - 1 个情况，若小于0，清零计算，大于0，不作改动。然后加nums[i],然后与前一时刻最大值比较。其实这里sum 相当于状态，maxsum就是历史。 Length of Last Word Plus One Sqrt(x) 耍了一个trick，直接从Integer.MAX_VALUE的平方根开始算。 Climbing Stairs Remove Duplicates from Sorted List easy，但是实现过程中还是有小问题： 1、没有判断是否相同直接跳到下一个节点导致：【1,1,1,1,1】处理完变成了【1,1,1】。因为第二个处理完之后跳到了第三个，处理完第四个跳到第五个。。。。 Merge Sorted Array 虽然不可以从最小的开始，但我们可以从最大的开始啊。 Add Binary StringBuilder 可以append不同类型的，不一定要char型。而且可以不同类型组合。 Maximum Depth of Binary Tree Same Tree Single Number 这个还是简单的，毕竟两个相同的数字进行异或即可。 Single Number II 这个就很难受了，弄了一个晚上。感受到了自己的菜鸡。 利用状态转移，设置不同状态表示接收到了不同的bit个数，因为某一个，数字的固定位置比特肯定是只出现一次的。 所以只要弄一个只有固定比特为1的状态，其余以方便优先选择。 Single Number III 位运算，求反，本来和原来的数完全相对，相与变成0，但是加1之后，能够找到最右不同的比特，也可以说从低到高第一个不同的bit 解释如下： 12345678 s1 a1 b1 c1 s2 a2 b2 c2^ ————— s a b c// NOT s_ a_ b_ c_ ————— ①c = 1,说明c1 c2 不同 ②c = 0,说明c1，c2相同，则c_ = 1， ③+1之后，将进位，也就等同于+1到b，继续①②两步 after find the rightest bit, then we diff &amp; -diff, we can make the bits lower than the rightest bit to zero, the rightest will be ‘1’ and those bits higher than the rightest will be ‘0’ because of ~ operation Integer to Roman easy Integer to English Words easy ZigZag Conversion 找规律题目 Generate Parentheses backtracking题目，但是属于easy的范围，仍然没有完全弄懂backtracking的原理，明天可以找backtracking题目进行熟悉。 Valid Palindrome easy，没有太刁难。首尾移动判断即可。 Valid Palindrome II 多了一个简单的判断。 Path Sum 思路还是很清晰的，但是在代码实现过程仍然要注意几个问题： 1、参数可以是null，但是不能对null进行操作，所以在对参数进行操作时要注意是否为null，尤其当对多个参数进行判断的时候。因为自己总是仅判断一个情况，那就是全为null的情况。 Symmetric Tree 这里居然出现了一个低级错误——对节点本身进行判断，而不是其中的值。。。 2018-4-29 Linked List Cycle 可以利用head作为标志，全部指向head，如果有一个节点已经指向了head说明了有loop，但是这样会破坏原来的数据结构。若要copy古来又无法满足without using extra space 2、brilliant，利用walker和runner，一个走一步一个走两步，如果loop肯定能相遇，如果到了末端没相遇则没有！ Letter Case Permutation backtrack 练习题，慢慢摸到了一点点门路。 现在对其理解就是 建立一个helper用于递归调用: 12345678910111213helper(...)&#123; if ( i &lt; len )&#123; if(isValid) go left; some operations; go right; else back to i-1(return ) &#125; else&#123; store; return; &#125;&#125; Linked List Cycle II 很遗憾，自己的方法还是不如别人的方法。 l1 = the distance from head to the node where cycle begins l2 = the distance from the node where cycle begins to the node where walker and runner meet l3 = the distance from the node where walker and runner meet to the node where cycle begins. when first meet, we have l1+l2 = (l1+l2+l3+l2) / 2, because the time used is the same so l1 = l3. Permutations 也算是知道了自己的错误了。思路没有错误，但是数据处理上出现了问题，因为lastres是重复使用的，当我add的时候一直加的同一个地址，所以最后在remove掉的时候把lastres所对应的空间数据全部remove掉导致没有任何数据了。 Letter Combinations of a Phone Number Permutations II 感觉很有代表性的一道题目，做出了这个题目之后其他的duplicate几乎有迎刃而解了。 Subsets Combinations Combination Sum Combination Sum II Combination Sum III Beautiful Arrangement 真的很强，从头遍历和从尾部遍历得到不同的branch，而从尾部能够更快的过滤掉无用的东西。难怪是medium。 2018-5-2 Rotate Image 思路清晰，但是代码编写上还有漏洞，比如 内外循环变量，内 j 外 i 应该是i &lt;= len/2 写成了 i &lt; len/2，而且 j也写成了 j &lt; len/2，本应该是 j &lt; len-1-i。。。。emmm这个问题的出现，主要还是自己从思路到代码方向上不能够有效的联系起来。 1、首先采用递归 123456789101112131415161718192021222324/*** Definition for singly-linked list.* public class ListNode &#123;* int val;* ListNode next;* ListNode(int x) &#123; val = x; &#125;* &#125;*/class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if ( head == null ) return null; ListNode Head = new ListNode(0); Head.next = head; swap(Head, head, head.next); return Head.next; &#125; public void swap(ListNode head, ListNode node1, ListNode node2)&#123; if ( node1 == null || node2 == null ) return; node1.next= node2.next; node2.next = node1; head.next = node2; swap(node1, node1.next, node1.next.next); &#125;&#125; 知道问题在哪里了，当node1.next已经是null的时候，node.next.next就要出问题了，因为null是没有next的，此时就会爆出NPE错误。更改后如下： 12345678910111213141516171819202122class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if ( head == null ) return null; ListNode Head = new ListNode(0); Head.next = head; if ( head.next == null ) return; swap(Head, head, head.next); return Head.next; &#125; public void swap(ListNode head, ListNode node1, ListNode node2)&#123; node1.next= node2.next; node2.next = node1; head.next = node2; if ( node1.next == null || node1.next.next == null ) return; swap(node1, node1.next, node1.next.next); &#125;&#125;when( lo &lt; hi)&#123; mid = (lo+hi) / 2; if ( nums[mid] &lt; nums[low] ) high = mid - 1; else low = mid;&#125; Swap Nodes in Pairs 1、函数可以接受null参数。 2、不能对null参数进行操作——也就是说，在链表中，head.next = null时，不能调用head.next.next；否则就是NPE错误。很关键。所以这个决定了是进了函数体之后再做判断，还是先判断再进函数体。 Remove Nth Node From End of List 保留头部，以n长度窗口移动，到tail时铲除head.next； Search in Rotated Sorted Array 很难受，其实思路一样，但是代码就是写着有问题。讲道理的话，找到最大值和找到最小值进行计算都一样。但是为什么最大值就无法正确的找到呢。。。 ！！！！！！ 很有意思的一道题目，帮我解决了BS的核心问题。 a_lo, a_mid, a_hi。前面之所以找最大值不能够正确的找到，问题出在最后一步。因为二分法无论如何最后总会变成 a_lo = a_mid， a_hi. 此时如果采用寻找最大值，就无法满足a_lo和a_mid是独立开的，导致之前一直依赖的逻辑出错。（因为不再满足这个逻辑） 而如果是采用寻找最小值，就能够满足a_mid和a_high是独立开的，最终找到正确的值！！ 总结为两点： 1、选择mid与high比较，不可选择mid与low比较 2、此时因为low high 有可能等于mid，若循环判断条件为 low &lt;= high会出现 low一直等于high的死循环，应该改为low &lt; high Search for a Range 先二分找到一个值，再在其左右二分寻找（是否需要左右寻找通过一个简单的左右值判断即可） Multiply Strings 也算比较蛋疼的一个题目吧，主要还是一些corner case的考虑不够周全。 1、没考虑到&quot;0&quot; 2、学到了String之间比较如果直接 ==比较是引用比较，比较的是地址，要比较内容需要用到equal函数 2018-5-3 61. Rotate List 又是一道rotate的题目，可以利用rotation的特性直接得到newhead和newtail的位置。但是要留一个HEAD定位真正的头的位置。 Reverse String 学到了String.valueOf() 1234567891011121314class Solution &#123; public String reverseString(String s) &#123; char[] c = s.toCharArray(); int l = c.length-1; int mid = (l+1)/2; char t; for(int i=0; i&lt;mid; i++)&#123; t = c[i]; c[i] = c[l-i]; c[l-i] = t; &#125; return String.valueOf(c); &#125;&#125; 2018-5-4 Reverse Words in a String III 两个新函数需要学习： String下的split，StringBuilder下的trim() 2018-5-4 Number of 1 Bits 学到了一个小技巧。。。 &quot;&gt;&gt;&gt;&quot;是logic shift Reverse Bits 思路没错。。。然而没想到是32bit，只做了有效位的reverse，高位的0刚刚开始没有reverse Power of Two 2018-5-5 Min Stack 我是按照之前coursera里面做的啊，为什么时间效率这么低，可能是数组空间变化的原因，但是原Java里面的Stack类不是吗？待会了解一下； Factorial Trailing Zeroes 自己总是陷入brute force的思路，很难受。。。 但是自己想到了5，没有仔细的深挖，或者说自己境界不够吧，居然在想着怎么凑2和5来算10的个数。。。其实只要看5就行了。 Rotate Array for those elements in the range of [n-k, n-1], they need to move to (i+k) % n, and when i+k is in the range of [n, 2n), we have (i+k) % n = i+k-n; for those elements in the range [0, n-k-1], they need just move to (i+k) like below: 12345670 n-k-1 n-k n-1[ | ] a1 range1 range2Thus, when we first reverse the whole array, we have the ist element in the new array which equals n-i-1, and now we have0 k-1 k n-1[ | ] a2 range2 range1 so when we reverse the first part of the new array a2(range2), the ist element in the new array part will be k-1-(n-i-1) = k+i-n and this is exactly what we need, the same as the second part after the reversion. House Robber easy DP solution but used O(N) space; it seems like there is a O(1) Space solution 2018-5-6 Container With Most Water 123456while(left &lt; right)&#123; if nums_left &lt; nums_right left++; else right-- update max&#125;return max; Remove Duplicates from Sorted Array II if-else problem happens again, when it comes to if-else branches, YOU NEED TO CHECK IF THE CORNER CASE THAT ONLY IF OR ELSE BRANCH IS APPROACHED. K-diff Pairs in an Array I do it by simple search like brute solution. However, there are some more efficient solutions like Two Pointers or HashMap, the latter is more understandable but the former is a little hard to understand fully 123456789101112131415class Solution &#123; public int findPairs(int[] nums, int k) &#123; if(k &lt; 0) return 0; int cnt = 0; Arrays.sort(nums); for(int i = 0, j = 1; j &lt; nums.length; )&#123; if(i &gt;= j || nums[i] + k &gt; nums[j]) j++; else if( i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] || nums[i] + k &lt; nums[j]) i++; else&#123; cnt++; i++; &#125; &#125; return cnt; &#125;&#125; Figure it out but don’t know how to come up with the idea. Minimum Size Subarray Sum two pointer i and j, sum to store the sum of subarray 12345678910for i,j = 0; j &lt;= nums.length;if ( sum &gt;= s ) &#123; update minlen; sum -= nums[i]; i++; &#125;else&#123; if( j == nums.length ) break; // j comes to the end and the increment of i will never enlarge the sum. so break; sum += nums[j]; j++;&#125; Sort Colors someone posted four different solution…omg… What a huge My idea: sort 0 then sort 1. two pass. don’t know the one pass solution… ① Insertion solution Explanation: restore the last index of 0, 1, 2 and when it comes a new num, we insert it and increment the corresponding index, eg insert 0, increase index of 0,1,2 but if insert 2 we only need to increase the index of 2. n0,n1,n2 12345678for( i from 0 to nums.length)&#123; if nums[i] = 0 nums[++n2] = 2; nums[++n1] = 1; nums[++n0] = 0 else if else &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
